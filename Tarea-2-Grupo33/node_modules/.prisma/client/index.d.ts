
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model personajes
 * 
 */
export type personajes = {
  id: number
  nombre: string
  fuerza: number
  fecha_nacimiento: Date
  objeto: string | null
}

/**
 * Model karts
 * 
 */
export type karts = {
  id: number
  modelo: string
  color: string
  velocidad_maxima: number | null
  id_personaje: number
}

/**
 * Model personaje_tiene_trabajo
 * 
 */
export type personaje_tiene_trabajo = {
  id_trabajo: number
  id_personaje: number
  fecha_inicio: Date
  fecha_termino: Date | null
}

/**
 * Model trabajos
 * 
 */
export type trabajos = {
  id: number
  descripcion: string
  sueldo: number
}

/**
 * Model personaje_habita_reino
 * 
 */
export type personaje_habita_reino = {
  id_personaje: number
  id_reino: number
  fecha_registro: Date
  es_gobernante: boolean
}

/**
 * Model reinos
 * 
 */
export type reinos = {
  id: number
  nombre: string
  ubicacion: string
  superficie: number
}

/**
 * Model defensas
 * 
 */
export type defensas = {
  id: number
  defensa: string
}

/**
 * Model reino_defensas
 * 
 */
export type reino_defensas = {
  reinoId: number
  defensaId: number
}

/**
 * Model diplomacias
 * 
 */
export type diplomacias = {
  id_reino_1: number
  id_reino_2: number
  es_aliado: boolean
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Personajes
 * const personajes = await prisma.personajes.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Personajes
   * const personajes = await prisma.personajes.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.personajes`: Exposes CRUD operations for the **personajes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personajes
    * const personajes = await prisma.personajes.findMany()
    * ```
    */
  get personajes(): Prisma.personajesDelegate<GlobalReject>;

  /**
   * `prisma.karts`: Exposes CRUD operations for the **karts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Karts
    * const karts = await prisma.karts.findMany()
    * ```
    */
  get karts(): Prisma.kartsDelegate<GlobalReject>;

  /**
   * `prisma.personaje_tiene_trabajo`: Exposes CRUD operations for the **personaje_tiene_trabajo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personaje_tiene_trabajos
    * const personaje_tiene_trabajos = await prisma.personaje_tiene_trabajo.findMany()
    * ```
    */
  get personaje_tiene_trabajo(): Prisma.personaje_tiene_trabajoDelegate<GlobalReject>;

  /**
   * `prisma.trabajos`: Exposes CRUD operations for the **trabajos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trabajos
    * const trabajos = await prisma.trabajos.findMany()
    * ```
    */
  get trabajos(): Prisma.trabajosDelegate<GlobalReject>;

  /**
   * `prisma.personaje_habita_reino`: Exposes CRUD operations for the **personaje_habita_reino** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personaje_habita_reinos
    * const personaje_habita_reinos = await prisma.personaje_habita_reino.findMany()
    * ```
    */
  get personaje_habita_reino(): Prisma.personaje_habita_reinoDelegate<GlobalReject>;

  /**
   * `prisma.reinos`: Exposes CRUD operations for the **reinos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reinos
    * const reinos = await prisma.reinos.findMany()
    * ```
    */
  get reinos(): Prisma.reinosDelegate<GlobalReject>;

  /**
   * `prisma.defensas`: Exposes CRUD operations for the **defensas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Defensas
    * const defensas = await prisma.defensas.findMany()
    * ```
    */
  get defensas(): Prisma.defensasDelegate<GlobalReject>;

  /**
   * `prisma.reino_defensas`: Exposes CRUD operations for the **reino_defensas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reino_defensas
    * const reino_defensas = await prisma.reino_defensas.findMany()
    * ```
    */
  get reino_defensas(): Prisma.reino_defensasDelegate<GlobalReject>;

  /**
   * `prisma.diplomacias`: Exposes CRUD operations for the **diplomacias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diplomacias
    * const diplomacias = await prisma.diplomacias.findMany()
    * ```
    */
  get diplomacias(): Prisma.diplomaciasDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.15.0
   * Query Engine version: 8fbc245156db7124f997f4cecdd8d1219e360944
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    personajes: 'personajes',
    karts: 'karts',
    personaje_tiene_trabajo: 'personaje_tiene_trabajo',
    trabajos: 'trabajos',
    personaje_habita_reino: 'personaje_habita_reino',
    reinos: 'reinos',
    defensas: 'defensas',
    reino_defensas: 'reino_defensas',
    diplomacias: 'diplomacias'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PersonajesCountOutputType
   */


  export type PersonajesCountOutputType = {
    personaje_tiene_trabajo: number
    karts: number
    personaje_habita_reino: number
  }

  export type PersonajesCountOutputTypeSelect = {
    personaje_tiene_trabajo?: boolean
    karts?: boolean
    personaje_habita_reino?: boolean
  }

  export type PersonajesCountOutputTypeGetPayload<S extends boolean | null | undefined | PersonajesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PersonajesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PersonajesCountOutputTypeArgs)
    ? PersonajesCountOutputType 
    : S extends { select: any } & (PersonajesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PersonajesCountOutputType ? PersonajesCountOutputType[P] : never
  } 
      : PersonajesCountOutputType




  // Custom InputTypes

  /**
   * PersonajesCountOutputType without action
   */
  export type PersonajesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PersonajesCountOutputType
     */
    select?: PersonajesCountOutputTypeSelect | null
  }



  /**
   * Count Type TrabajosCountOutputType
   */


  export type TrabajosCountOutputType = {
    personaje_tiene_trabajo: number
  }

  export type TrabajosCountOutputTypeSelect = {
    personaje_tiene_trabajo?: boolean
  }

  export type TrabajosCountOutputTypeGetPayload<S extends boolean | null | undefined | TrabajosCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TrabajosCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TrabajosCountOutputTypeArgs)
    ? TrabajosCountOutputType 
    : S extends { select: any } & (TrabajosCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TrabajosCountOutputType ? TrabajosCountOutputType[P] : never
  } 
      : TrabajosCountOutputType




  // Custom InputTypes

  /**
   * TrabajosCountOutputType without action
   */
  export type TrabajosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TrabajosCountOutputType
     */
    select?: TrabajosCountOutputTypeSelect | null
  }



  /**
   * Count Type ReinosCountOutputType
   */


  export type ReinosCountOutputType = {
    personaje_habita_reino: number
    diplomaciasAsociadas1: number
    diplomaciasAsociadas2: number
    reino_defensas: number
  }

  export type ReinosCountOutputTypeSelect = {
    personaje_habita_reino?: boolean
    diplomaciasAsociadas1?: boolean
    diplomaciasAsociadas2?: boolean
    reino_defensas?: boolean
  }

  export type ReinosCountOutputTypeGetPayload<S extends boolean | null | undefined | ReinosCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ReinosCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ReinosCountOutputTypeArgs)
    ? ReinosCountOutputType 
    : S extends { select: any } & (ReinosCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ReinosCountOutputType ? ReinosCountOutputType[P] : never
  } 
      : ReinosCountOutputType




  // Custom InputTypes

  /**
   * ReinosCountOutputType without action
   */
  export type ReinosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReinosCountOutputType
     */
    select?: ReinosCountOutputTypeSelect | null
  }



  /**
   * Count Type DefensasCountOutputType
   */


  export type DefensasCountOutputType = {
    reino_defensas: number
  }

  export type DefensasCountOutputTypeSelect = {
    reino_defensas?: boolean
  }

  export type DefensasCountOutputTypeGetPayload<S extends boolean | null | undefined | DefensasCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DefensasCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DefensasCountOutputTypeArgs)
    ? DefensasCountOutputType 
    : S extends { select: any } & (DefensasCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DefensasCountOutputType ? DefensasCountOutputType[P] : never
  } 
      : DefensasCountOutputType




  // Custom InputTypes

  /**
   * DefensasCountOutputType without action
   */
  export type DefensasCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DefensasCountOutputType
     */
    select?: DefensasCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model personajes
   */


  export type AggregatePersonajes = {
    _count: PersonajesCountAggregateOutputType | null
    _avg: PersonajesAvgAggregateOutputType | null
    _sum: PersonajesSumAggregateOutputType | null
    _min: PersonajesMinAggregateOutputType | null
    _max: PersonajesMaxAggregateOutputType | null
  }

  export type PersonajesAvgAggregateOutputType = {
    id: number | null
    fuerza: number | null
  }

  export type PersonajesSumAggregateOutputType = {
    id: number | null
    fuerza: number | null
  }

  export type PersonajesMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    fuerza: number | null
    fecha_nacimiento: Date | null
    objeto: string | null
  }

  export type PersonajesMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    fuerza: number | null
    fecha_nacimiento: Date | null
    objeto: string | null
  }

  export type PersonajesCountAggregateOutputType = {
    id: number
    nombre: number
    fuerza: number
    fecha_nacimiento: number
    objeto: number
    _all: number
  }


  export type PersonajesAvgAggregateInputType = {
    id?: true
    fuerza?: true
  }

  export type PersonajesSumAggregateInputType = {
    id?: true
    fuerza?: true
  }

  export type PersonajesMinAggregateInputType = {
    id?: true
    nombre?: true
    fuerza?: true
    fecha_nacimiento?: true
    objeto?: true
  }

  export type PersonajesMaxAggregateInputType = {
    id?: true
    nombre?: true
    fuerza?: true
    fecha_nacimiento?: true
    objeto?: true
  }

  export type PersonajesCountAggregateInputType = {
    id?: true
    nombre?: true
    fuerza?: true
    fecha_nacimiento?: true
    objeto?: true
    _all?: true
  }

  export type PersonajesAggregateArgs = {
    /**
     * Filter which personajes to aggregate.
     */
    where?: personajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personajes to fetch.
     */
    orderBy?: Enumerable<personajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personajes
    **/
    _count?: true | PersonajesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonajesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonajesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonajesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonajesMaxAggregateInputType
  }

  export type GetPersonajesAggregateType<T extends PersonajesAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonajes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonajes[P]>
      : GetScalarType<T[P], AggregatePersonajes[P]>
  }




  export type PersonajesGroupByArgs = {
    where?: personajesWhereInput
    orderBy?: Enumerable<personajesOrderByWithAggregationInput>
    by: PersonajesScalarFieldEnum[]
    having?: personajesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonajesCountAggregateInputType | true
    _avg?: PersonajesAvgAggregateInputType
    _sum?: PersonajesSumAggregateInputType
    _min?: PersonajesMinAggregateInputType
    _max?: PersonajesMaxAggregateInputType
  }


  export type PersonajesGroupByOutputType = {
    id: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date
    objeto: string | null
    _count: PersonajesCountAggregateOutputType | null
    _avg: PersonajesAvgAggregateOutputType | null
    _sum: PersonajesSumAggregateOutputType | null
    _min: PersonajesMinAggregateOutputType | null
    _max: PersonajesMaxAggregateOutputType | null
  }

  type GetPersonajesGroupByPayload<T extends PersonajesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonajesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonajesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonajesGroupByOutputType[P]>
            : GetScalarType<T[P], PersonajesGroupByOutputType[P]>
        }
      >
    >


  export type personajesSelect = {
    id?: boolean
    nombre?: boolean
    fuerza?: boolean
    fecha_nacimiento?: boolean
    objeto?: boolean
    personaje_tiene_trabajo?: boolean | personajes$personaje_tiene_trabajoArgs
    karts?: boolean | personajes$kartsArgs
    personaje_habita_reino?: boolean | personajes$personaje_habita_reinoArgs
    _count?: boolean | PersonajesCountOutputTypeArgs
  }


  export type personajesInclude = {
    personaje_tiene_trabajo?: boolean | personajes$personaje_tiene_trabajoArgs
    karts?: boolean | personajes$kartsArgs
    personaje_habita_reino?: boolean | personajes$personaje_habita_reinoArgs
    _count?: boolean | PersonajesCountOutputTypeArgs
  }

  export type personajesGetPayload<S extends boolean | null | undefined | personajesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? personajes :
    S extends undefined ? never :
    S extends { include: any } & (personajesArgs | personajesFindManyArgs)
    ? personajes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje_tiene_trabajo' ? Array < personaje_tiene_trabajoGetPayload<S['include'][P]>>  :
        P extends 'karts' ? Array < kartsGetPayload<S['include'][P]>>  :
        P extends 'personaje_habita_reino' ? Array < personaje_habita_reinoGetPayload<S['include'][P]>>  :
        P extends '_count' ? PersonajesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (personajesArgs | personajesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje_tiene_trabajo' ? Array < personaje_tiene_trabajoGetPayload<S['select'][P]>>  :
        P extends 'karts' ? Array < kartsGetPayload<S['select'][P]>>  :
        P extends 'personaje_habita_reino' ? Array < personaje_habita_reinoGetPayload<S['select'][P]>>  :
        P extends '_count' ? PersonajesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof personajes ? personajes[P] : never
  } 
      : personajes


  type personajesCountArgs = 
    Omit<personajesFindManyArgs, 'select' | 'include'> & {
      select?: PersonajesCountAggregateInputType | true
    }

  export interface personajesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personajes that matches the filter.
     * @param {personajesFindUniqueArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends personajesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, personajesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'personajes'> extends True ? Prisma__personajesClient<personajesGetPayload<T>> : Prisma__personajesClient<personajesGetPayload<T> | null, null>

    /**
     * Find one Personajes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {personajesFindUniqueOrThrowArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends personajesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, personajesFindUniqueOrThrowArgs>
    ): Prisma__personajesClient<personajesGetPayload<T>>

    /**
     * Find the first Personajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personajesFindFirstArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends personajesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, personajesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'personajes'> extends True ? Prisma__personajesClient<personajesGetPayload<T>> : Prisma__personajesClient<personajesGetPayload<T> | null, null>

    /**
     * Find the first Personajes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personajesFindFirstOrThrowArgs} args - Arguments to find a Personajes
     * @example
     * // Get one Personajes
     * const personajes = await prisma.personajes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends personajesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, personajesFindFirstOrThrowArgs>
    ): Prisma__personajesClient<personajesGetPayload<T>>

    /**
     * Find zero or more Personajes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personajesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personajes
     * const personajes = await prisma.personajes.findMany()
     * 
     * // Get first 10 Personajes
     * const personajes = await prisma.personajes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personajesWithIdOnly = await prisma.personajes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends personajesFindManyArgs>(
      args?: SelectSubset<T, personajesFindManyArgs>
    ): Prisma.PrismaPromise<Array<personajesGetPayload<T>>>

    /**
     * Create a Personajes.
     * @param {personajesCreateArgs} args - Arguments to create a Personajes.
     * @example
     * // Create one Personajes
     * const Personajes = await prisma.personajes.create({
     *   data: {
     *     // ... data to create a Personajes
     *   }
     * })
     * 
    **/
    create<T extends personajesCreateArgs>(
      args: SelectSubset<T, personajesCreateArgs>
    ): Prisma__personajesClient<personajesGetPayload<T>>

    /**
     * Create many Personajes.
     *     @param {personajesCreateManyArgs} args - Arguments to create many Personajes.
     *     @example
     *     // Create many Personajes
     *     const personajes = await prisma.personajes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends personajesCreateManyArgs>(
      args?: SelectSubset<T, personajesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personajes.
     * @param {personajesDeleteArgs} args - Arguments to delete one Personajes.
     * @example
     * // Delete one Personajes
     * const Personajes = await prisma.personajes.delete({
     *   where: {
     *     // ... filter to delete one Personajes
     *   }
     * })
     * 
    **/
    delete<T extends personajesDeleteArgs>(
      args: SelectSubset<T, personajesDeleteArgs>
    ): Prisma__personajesClient<personajesGetPayload<T>>

    /**
     * Update one Personajes.
     * @param {personajesUpdateArgs} args - Arguments to update one Personajes.
     * @example
     * // Update one Personajes
     * const personajes = await prisma.personajes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends personajesUpdateArgs>(
      args: SelectSubset<T, personajesUpdateArgs>
    ): Prisma__personajesClient<personajesGetPayload<T>>

    /**
     * Delete zero or more Personajes.
     * @param {personajesDeleteManyArgs} args - Arguments to filter Personajes to delete.
     * @example
     * // Delete a few Personajes
     * const { count } = await prisma.personajes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends personajesDeleteManyArgs>(
      args?: SelectSubset<T, personajesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personajesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personajes
     * const personajes = await prisma.personajes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends personajesUpdateManyArgs>(
      args: SelectSubset<T, personajesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personajes.
     * @param {personajesUpsertArgs} args - Arguments to update or create a Personajes.
     * @example
     * // Update or create a Personajes
     * const personajes = await prisma.personajes.upsert({
     *   create: {
     *     // ... data to create a Personajes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personajes we want to update
     *   }
     * })
    **/
    upsert<T extends personajesUpsertArgs>(
      args: SelectSubset<T, personajesUpsertArgs>
    ): Prisma__personajesClient<personajesGetPayload<T>>

    /**
     * Count the number of Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personajesCountArgs} args - Arguments to filter Personajes to count.
     * @example
     * // Count the number of Personajes
     * const count = await prisma.personajes.count({
     *   where: {
     *     // ... the filter for the Personajes we want to count
     *   }
     * })
    **/
    count<T extends personajesCountArgs>(
      args?: Subset<T, personajesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonajesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonajesAggregateArgs>(args: Subset<T, PersonajesAggregateArgs>): Prisma.PrismaPromise<GetPersonajesAggregateType<T>>

    /**
     * Group by Personajes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonajesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonajesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonajesGroupByArgs['orderBy'] }
        : { orderBy?: PersonajesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonajesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonajesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for personajes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__personajesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje_tiene_trabajo<T extends personajes$personaje_tiene_trabajoArgs= {}>(args?: Subset<T, personajes$personaje_tiene_trabajoArgs>): Prisma.PrismaPromise<Array<personaje_tiene_trabajoGetPayload<T>>| Null>;

    karts<T extends personajes$kartsArgs= {}>(args?: Subset<T, personajes$kartsArgs>): Prisma.PrismaPromise<Array<kartsGetPayload<T>>| Null>;

    personaje_habita_reino<T extends personajes$personaje_habita_reinoArgs= {}>(args?: Subset<T, personajes$personaje_habita_reinoArgs>): Prisma.PrismaPromise<Array<personaje_habita_reinoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * personajes base type for findUnique actions
   */
  export type personajesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * Filter, which personajes to fetch.
     */
    where: personajesWhereUniqueInput
  }

  /**
   * personajes findUnique
   */
  export interface personajesFindUniqueArgs extends personajesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personajes findUniqueOrThrow
   */
  export type personajesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * Filter, which personajes to fetch.
     */
    where: personajesWhereUniqueInput
  }


  /**
   * personajes base type for findFirst actions
   */
  export type personajesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * Filter, which personajes to fetch.
     */
    where?: personajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personajes to fetch.
     */
    orderBy?: Enumerable<personajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personajes.
     */
    cursor?: personajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personajes.
     */
    distinct?: Enumerable<PersonajesScalarFieldEnum>
  }

  /**
   * personajes findFirst
   */
  export interface personajesFindFirstArgs extends personajesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personajes findFirstOrThrow
   */
  export type personajesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * Filter, which personajes to fetch.
     */
    where?: personajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personajes to fetch.
     */
    orderBy?: Enumerable<personajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personajes.
     */
    cursor?: personajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personajes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personajes.
     */
    distinct?: Enumerable<PersonajesScalarFieldEnum>
  }


  /**
   * personajes findMany
   */
  export type personajesFindManyArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * Filter, which personajes to fetch.
     */
    where?: personajesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personajes to fetch.
     */
    orderBy?: Enumerable<personajesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personajes.
     */
    cursor?: personajesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personajes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personajes.
     */
    skip?: number
    distinct?: Enumerable<PersonajesScalarFieldEnum>
  }


  /**
   * personajes create
   */
  export type personajesCreateArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * The data needed to create a personajes.
     */
    data: XOR<personajesCreateInput, personajesUncheckedCreateInput>
  }


  /**
   * personajes createMany
   */
  export type personajesCreateManyArgs = {
    /**
     * The data used to create many personajes.
     */
    data: Enumerable<personajesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * personajes update
   */
  export type personajesUpdateArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * The data needed to update a personajes.
     */
    data: XOR<personajesUpdateInput, personajesUncheckedUpdateInput>
    /**
     * Choose, which personajes to update.
     */
    where: personajesWhereUniqueInput
  }


  /**
   * personajes updateMany
   */
  export type personajesUpdateManyArgs = {
    /**
     * The data used to update personajes.
     */
    data: XOR<personajesUpdateManyMutationInput, personajesUncheckedUpdateManyInput>
    /**
     * Filter which personajes to update
     */
    where?: personajesWhereInput
  }


  /**
   * personajes upsert
   */
  export type personajesUpsertArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * The filter to search for the personajes to update in case it exists.
     */
    where: personajesWhereUniqueInput
    /**
     * In case the personajes found by the `where` argument doesn't exist, create a new personajes with this data.
     */
    create: XOR<personajesCreateInput, personajesUncheckedCreateInput>
    /**
     * In case the personajes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personajesUpdateInput, personajesUncheckedUpdateInput>
  }


  /**
   * personajes delete
   */
  export type personajesDeleteArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
    /**
     * Filter which personajes to delete.
     */
    where: personajesWhereUniqueInput
  }


  /**
   * personajes deleteMany
   */
  export type personajesDeleteManyArgs = {
    /**
     * Filter which personajes to delete
     */
    where?: personajesWhereInput
  }


  /**
   * personajes.personaje_tiene_trabajo
   */
  export type personajes$personaje_tiene_trabajoArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    where?: personaje_tiene_trabajoWhereInput
    orderBy?: Enumerable<personaje_tiene_trabajoOrderByWithRelationInput>
    cursor?: personaje_tiene_trabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * personajes.karts
   */
  export type personajes$kartsArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    where?: kartsWhereInput
    orderBy?: Enumerable<kartsOrderByWithRelationInput>
    cursor?: kartsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KartsScalarFieldEnum>
  }


  /**
   * personajes.personaje_habita_reino
   */
  export type personajes$personaje_habita_reinoArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    where?: personaje_habita_reinoWhereInput
    orderBy?: Enumerable<personaje_habita_reinoOrderByWithRelationInput>
    cursor?: personaje_habita_reinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * personajes without action
   */
  export type personajesArgs = {
    /**
     * Select specific fields to fetch from the personajes
     */
    select?: personajesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personajesInclude | null
  }



  /**
   * Model karts
   */


  export type AggregateKarts = {
    _count: KartsCountAggregateOutputType | null
    _avg: KartsAvgAggregateOutputType | null
    _sum: KartsSumAggregateOutputType | null
    _min: KartsMinAggregateOutputType | null
    _max: KartsMaxAggregateOutputType | null
  }

  export type KartsAvgAggregateOutputType = {
    id: number | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsSumAggregateOutputType = {
    id: number | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsMinAggregateOutputType = {
    id: number | null
    modelo: string | null
    color: string | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsMaxAggregateOutputType = {
    id: number | null
    modelo: string | null
    color: string | null
    velocidad_maxima: number | null
    id_personaje: number | null
  }

  export type KartsCountAggregateOutputType = {
    id: number
    modelo: number
    color: number
    velocidad_maxima: number
    id_personaje: number
    _all: number
  }


  export type KartsAvgAggregateInputType = {
    id?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsSumAggregateInputType = {
    id?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsMinAggregateInputType = {
    id?: true
    modelo?: true
    color?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsMaxAggregateInputType = {
    id?: true
    modelo?: true
    color?: true
    velocidad_maxima?: true
    id_personaje?: true
  }

  export type KartsCountAggregateInputType = {
    id?: true
    modelo?: true
    color?: true
    velocidad_maxima?: true
    id_personaje?: true
    _all?: true
  }

  export type KartsAggregateArgs = {
    /**
     * Filter which karts to aggregate.
     */
    where?: kartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karts to fetch.
     */
    orderBy?: Enumerable<kartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned karts
    **/
    _count?: true | KartsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KartsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KartsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KartsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KartsMaxAggregateInputType
  }

  export type GetKartsAggregateType<T extends KartsAggregateArgs> = {
        [P in keyof T & keyof AggregateKarts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKarts[P]>
      : GetScalarType<T[P], AggregateKarts[P]>
  }




  export type KartsGroupByArgs = {
    where?: kartsWhereInput
    orderBy?: Enumerable<kartsOrderByWithAggregationInput>
    by: KartsScalarFieldEnum[]
    having?: kartsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KartsCountAggregateInputType | true
    _avg?: KartsAvgAggregateInputType
    _sum?: KartsSumAggregateInputType
    _min?: KartsMinAggregateInputType
    _max?: KartsMaxAggregateInputType
  }


  export type KartsGroupByOutputType = {
    id: number
    modelo: string
    color: string
    velocidad_maxima: number | null
    id_personaje: number
    _count: KartsCountAggregateOutputType | null
    _avg: KartsAvgAggregateOutputType | null
    _sum: KartsSumAggregateOutputType | null
    _min: KartsMinAggregateOutputType | null
    _max: KartsMaxAggregateOutputType | null
  }

  type GetKartsGroupByPayload<T extends KartsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KartsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KartsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KartsGroupByOutputType[P]>
            : GetScalarType<T[P], KartsGroupByOutputType[P]>
        }
      >
    >


  export type kartsSelect = {
    id?: boolean
    modelo?: boolean
    color?: boolean
    velocidad_maxima?: boolean
    id_personaje?: boolean
    personaje?: boolean | personajesArgs
  }


  export type kartsInclude = {
    personaje?: boolean | personajesArgs
  }

  export type kartsGetPayload<S extends boolean | null | undefined | kartsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? karts :
    S extends undefined ? never :
    S extends { include: any } & (kartsArgs | kartsFindManyArgs)
    ? karts  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje' ? personajesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (kartsArgs | kartsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje' ? personajesGetPayload<S['select'][P]> :  P extends keyof karts ? karts[P] : never
  } 
      : karts


  type kartsCountArgs = 
    Omit<kartsFindManyArgs, 'select' | 'include'> & {
      select?: KartsCountAggregateInputType | true
    }

  export interface kartsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Karts that matches the filter.
     * @param {kartsFindUniqueArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends kartsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, kartsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'karts'> extends True ? Prisma__kartsClient<kartsGetPayload<T>> : Prisma__kartsClient<kartsGetPayload<T> | null, null>

    /**
     * Find one Karts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {kartsFindUniqueOrThrowArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends kartsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, kartsFindUniqueOrThrowArgs>
    ): Prisma__kartsClient<kartsGetPayload<T>>

    /**
     * Find the first Karts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kartsFindFirstArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends kartsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, kartsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'karts'> extends True ? Prisma__kartsClient<kartsGetPayload<T>> : Prisma__kartsClient<kartsGetPayload<T> | null, null>

    /**
     * Find the first Karts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kartsFindFirstOrThrowArgs} args - Arguments to find a Karts
     * @example
     * // Get one Karts
     * const karts = await prisma.karts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends kartsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, kartsFindFirstOrThrowArgs>
    ): Prisma__kartsClient<kartsGetPayload<T>>

    /**
     * Find zero or more Karts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kartsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Karts
     * const karts = await prisma.karts.findMany()
     * 
     * // Get first 10 Karts
     * const karts = await prisma.karts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kartsWithIdOnly = await prisma.karts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends kartsFindManyArgs>(
      args?: SelectSubset<T, kartsFindManyArgs>
    ): Prisma.PrismaPromise<Array<kartsGetPayload<T>>>

    /**
     * Create a Karts.
     * @param {kartsCreateArgs} args - Arguments to create a Karts.
     * @example
     * // Create one Karts
     * const Karts = await prisma.karts.create({
     *   data: {
     *     // ... data to create a Karts
     *   }
     * })
     * 
    **/
    create<T extends kartsCreateArgs>(
      args: SelectSubset<T, kartsCreateArgs>
    ): Prisma__kartsClient<kartsGetPayload<T>>

    /**
     * Create many Karts.
     *     @param {kartsCreateManyArgs} args - Arguments to create many Karts.
     *     @example
     *     // Create many Karts
     *     const karts = await prisma.karts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends kartsCreateManyArgs>(
      args?: SelectSubset<T, kartsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Karts.
     * @param {kartsDeleteArgs} args - Arguments to delete one Karts.
     * @example
     * // Delete one Karts
     * const Karts = await prisma.karts.delete({
     *   where: {
     *     // ... filter to delete one Karts
     *   }
     * })
     * 
    **/
    delete<T extends kartsDeleteArgs>(
      args: SelectSubset<T, kartsDeleteArgs>
    ): Prisma__kartsClient<kartsGetPayload<T>>

    /**
     * Update one Karts.
     * @param {kartsUpdateArgs} args - Arguments to update one Karts.
     * @example
     * // Update one Karts
     * const karts = await prisma.karts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends kartsUpdateArgs>(
      args: SelectSubset<T, kartsUpdateArgs>
    ): Prisma__kartsClient<kartsGetPayload<T>>

    /**
     * Delete zero or more Karts.
     * @param {kartsDeleteManyArgs} args - Arguments to filter Karts to delete.
     * @example
     * // Delete a few Karts
     * const { count } = await prisma.karts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends kartsDeleteManyArgs>(
      args?: SelectSubset<T, kartsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kartsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Karts
     * const karts = await prisma.karts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends kartsUpdateManyArgs>(
      args: SelectSubset<T, kartsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Karts.
     * @param {kartsUpsertArgs} args - Arguments to update or create a Karts.
     * @example
     * // Update or create a Karts
     * const karts = await prisma.karts.upsert({
     *   create: {
     *     // ... data to create a Karts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Karts we want to update
     *   }
     * })
    **/
    upsert<T extends kartsUpsertArgs>(
      args: SelectSubset<T, kartsUpsertArgs>
    ): Prisma__kartsClient<kartsGetPayload<T>>

    /**
     * Count the number of Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kartsCountArgs} args - Arguments to filter Karts to count.
     * @example
     * // Count the number of Karts
     * const count = await prisma.karts.count({
     *   where: {
     *     // ... the filter for the Karts we want to count
     *   }
     * })
    **/
    count<T extends kartsCountArgs>(
      args?: Subset<T, kartsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KartsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KartsAggregateArgs>(args: Subset<T, KartsAggregateArgs>): Prisma.PrismaPromise<GetKartsAggregateType<T>>

    /**
     * Group by Karts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KartsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KartsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KartsGroupByArgs['orderBy'] }
        : { orderBy?: KartsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KartsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKartsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for karts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__kartsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje<T extends personajesArgs= {}>(args?: Subset<T, personajesArgs>): Prisma__personajesClient<personajesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * karts base type for findUnique actions
   */
  export type kartsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * Filter, which karts to fetch.
     */
    where: kartsWhereUniqueInput
  }

  /**
   * karts findUnique
   */
  export interface kartsFindUniqueArgs extends kartsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * karts findUniqueOrThrow
   */
  export type kartsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * Filter, which karts to fetch.
     */
    where: kartsWhereUniqueInput
  }


  /**
   * karts base type for findFirst actions
   */
  export type kartsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * Filter, which karts to fetch.
     */
    where?: kartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karts to fetch.
     */
    orderBy?: Enumerable<kartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for karts.
     */
    cursor?: kartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of karts.
     */
    distinct?: Enumerable<KartsScalarFieldEnum>
  }

  /**
   * karts findFirst
   */
  export interface kartsFindFirstArgs extends kartsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * karts findFirstOrThrow
   */
  export type kartsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * Filter, which karts to fetch.
     */
    where?: kartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karts to fetch.
     */
    orderBy?: Enumerable<kartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for karts.
     */
    cursor?: kartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of karts.
     */
    distinct?: Enumerable<KartsScalarFieldEnum>
  }


  /**
   * karts findMany
   */
  export type kartsFindManyArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * Filter, which karts to fetch.
     */
    where?: kartsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of karts to fetch.
     */
    orderBy?: Enumerable<kartsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing karts.
     */
    cursor?: kartsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` karts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` karts.
     */
    skip?: number
    distinct?: Enumerable<KartsScalarFieldEnum>
  }


  /**
   * karts create
   */
  export type kartsCreateArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * The data needed to create a karts.
     */
    data: XOR<kartsCreateInput, kartsUncheckedCreateInput>
  }


  /**
   * karts createMany
   */
  export type kartsCreateManyArgs = {
    /**
     * The data used to create many karts.
     */
    data: Enumerable<kartsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * karts update
   */
  export type kartsUpdateArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * The data needed to update a karts.
     */
    data: XOR<kartsUpdateInput, kartsUncheckedUpdateInput>
    /**
     * Choose, which karts to update.
     */
    where: kartsWhereUniqueInput
  }


  /**
   * karts updateMany
   */
  export type kartsUpdateManyArgs = {
    /**
     * The data used to update karts.
     */
    data: XOR<kartsUpdateManyMutationInput, kartsUncheckedUpdateManyInput>
    /**
     * Filter which karts to update
     */
    where?: kartsWhereInput
  }


  /**
   * karts upsert
   */
  export type kartsUpsertArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * The filter to search for the karts to update in case it exists.
     */
    where: kartsWhereUniqueInput
    /**
     * In case the karts found by the `where` argument doesn't exist, create a new karts with this data.
     */
    create: XOR<kartsCreateInput, kartsUncheckedCreateInput>
    /**
     * In case the karts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kartsUpdateInput, kartsUncheckedUpdateInput>
  }


  /**
   * karts delete
   */
  export type kartsDeleteArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
    /**
     * Filter which karts to delete.
     */
    where: kartsWhereUniqueInput
  }


  /**
   * karts deleteMany
   */
  export type kartsDeleteManyArgs = {
    /**
     * Filter which karts to delete
     */
    where?: kartsWhereInput
  }


  /**
   * karts without action
   */
  export type kartsArgs = {
    /**
     * Select specific fields to fetch from the karts
     */
    select?: kartsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: kartsInclude | null
  }



  /**
   * Model personaje_tiene_trabajo
   */


  export type AggregatePersonaje_tiene_trabajo = {
    _count: Personaje_tiene_trabajoCountAggregateOutputType | null
    _avg: Personaje_tiene_trabajoAvgAggregateOutputType | null
    _sum: Personaje_tiene_trabajoSumAggregateOutputType | null
    _min: Personaje_tiene_trabajoMinAggregateOutputType | null
    _max: Personaje_tiene_trabajoMaxAggregateOutputType | null
  }

  export type Personaje_tiene_trabajoAvgAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
  }

  export type Personaje_tiene_trabajoSumAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
  }

  export type Personaje_tiene_trabajoMinAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
    fecha_inicio: Date | null
    fecha_termino: Date | null
  }

  export type Personaje_tiene_trabajoMaxAggregateOutputType = {
    id_trabajo: number | null
    id_personaje: number | null
    fecha_inicio: Date | null
    fecha_termino: Date | null
  }

  export type Personaje_tiene_trabajoCountAggregateOutputType = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: number
    fecha_termino: number
    _all: number
  }


  export type Personaje_tiene_trabajoAvgAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
  }

  export type Personaje_tiene_trabajoSumAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
  }

  export type Personaje_tiene_trabajoMinAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
    fecha_inicio?: true
    fecha_termino?: true
  }

  export type Personaje_tiene_trabajoMaxAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
    fecha_inicio?: true
    fecha_termino?: true
  }

  export type Personaje_tiene_trabajoCountAggregateInputType = {
    id_trabajo?: true
    id_personaje?: true
    fecha_inicio?: true
    fecha_termino?: true
    _all?: true
  }

  export type Personaje_tiene_trabajoAggregateArgs = {
    /**
     * Filter which personaje_tiene_trabajo to aggregate.
     */
    where?: personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_tiene_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personaje_tiene_trabajos
    **/
    _count?: true | Personaje_tiene_trabajoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personaje_tiene_trabajoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personaje_tiene_trabajoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personaje_tiene_trabajoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personaje_tiene_trabajoMaxAggregateInputType
  }

  export type GetPersonaje_tiene_trabajoAggregateType<T extends Personaje_tiene_trabajoAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonaje_tiene_trabajo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonaje_tiene_trabajo[P]>
      : GetScalarType<T[P], AggregatePersonaje_tiene_trabajo[P]>
  }




  export type Personaje_tiene_trabajoGroupByArgs = {
    where?: personaje_tiene_trabajoWhereInput
    orderBy?: Enumerable<personaje_tiene_trabajoOrderByWithAggregationInput>
    by: Personaje_tiene_trabajoScalarFieldEnum[]
    having?: personaje_tiene_trabajoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personaje_tiene_trabajoCountAggregateInputType | true
    _avg?: Personaje_tiene_trabajoAvgAggregateInputType
    _sum?: Personaje_tiene_trabajoSumAggregateInputType
    _min?: Personaje_tiene_trabajoMinAggregateInputType
    _max?: Personaje_tiene_trabajoMaxAggregateInputType
  }


  export type Personaje_tiene_trabajoGroupByOutputType = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: Date
    fecha_termino: Date | null
    _count: Personaje_tiene_trabajoCountAggregateOutputType | null
    _avg: Personaje_tiene_trabajoAvgAggregateOutputType | null
    _sum: Personaje_tiene_trabajoSumAggregateOutputType | null
    _min: Personaje_tiene_trabajoMinAggregateOutputType | null
    _max: Personaje_tiene_trabajoMaxAggregateOutputType | null
  }

  type GetPersonaje_tiene_trabajoGroupByPayload<T extends Personaje_tiene_trabajoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Personaje_tiene_trabajoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Personaje_tiene_trabajoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Personaje_tiene_trabajoGroupByOutputType[P]>
            : GetScalarType<T[P], Personaje_tiene_trabajoGroupByOutputType[P]>
        }
      >
    >


  export type personaje_tiene_trabajoSelect = {
    id_trabajo?: boolean
    id_personaje?: boolean
    fecha_inicio?: boolean
    fecha_termino?: boolean
    trabajo?: boolean | trabajosArgs
    personaje?: boolean | personajesArgs
  }


  export type personaje_tiene_trabajoInclude = {
    trabajo?: boolean | trabajosArgs
    personaje?: boolean | personajesArgs
  }

  export type personaje_tiene_trabajoGetPayload<S extends boolean | null | undefined | personaje_tiene_trabajoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? personaje_tiene_trabajo :
    S extends undefined ? never :
    S extends { include: any } & (personaje_tiene_trabajoArgs | personaje_tiene_trabajoFindManyArgs)
    ? personaje_tiene_trabajo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'trabajo' ? trabajosGetPayload<S['include'][P]> :
        P extends 'personaje' ? personajesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (personaje_tiene_trabajoArgs | personaje_tiene_trabajoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'trabajo' ? trabajosGetPayload<S['select'][P]> :
        P extends 'personaje' ? personajesGetPayload<S['select'][P]> :  P extends keyof personaje_tiene_trabajo ? personaje_tiene_trabajo[P] : never
  } 
      : personaje_tiene_trabajo


  type personaje_tiene_trabajoCountArgs = 
    Omit<personaje_tiene_trabajoFindManyArgs, 'select' | 'include'> & {
      select?: Personaje_tiene_trabajoCountAggregateInputType | true
    }

  export interface personaje_tiene_trabajoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personaje_tiene_trabajo that matches the filter.
     * @param {personaje_tiene_trabajoFindUniqueArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends personaje_tiene_trabajoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, personaje_tiene_trabajoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'personaje_tiene_trabajo'> extends True ? Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>> : Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T> | null, null>

    /**
     * Find one Personaje_tiene_trabajo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {personaje_tiene_trabajoFindUniqueOrThrowArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends personaje_tiene_trabajoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, personaje_tiene_trabajoFindUniqueOrThrowArgs>
    ): Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>>

    /**
     * Find the first Personaje_tiene_trabajo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_tiene_trabajoFindFirstArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends personaje_tiene_trabajoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, personaje_tiene_trabajoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'personaje_tiene_trabajo'> extends True ? Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>> : Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T> | null, null>

    /**
     * Find the first Personaje_tiene_trabajo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_tiene_trabajoFindFirstOrThrowArgs} args - Arguments to find a Personaje_tiene_trabajo
     * @example
     * // Get one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends personaje_tiene_trabajoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, personaje_tiene_trabajoFindFirstOrThrowArgs>
    ): Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>>

    /**
     * Find zero or more Personaje_tiene_trabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_tiene_trabajoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personaje_tiene_trabajos
     * const personaje_tiene_trabajos = await prisma.personaje_tiene_trabajo.findMany()
     * 
     * // Get first 10 Personaje_tiene_trabajos
     * const personaje_tiene_trabajos = await prisma.personaje_tiene_trabajo.findMany({ take: 10 })
     * 
     * // Only select the `id_trabajo`
     * const personaje_tiene_trabajoWithId_trabajoOnly = await prisma.personaje_tiene_trabajo.findMany({ select: { id_trabajo: true } })
     * 
    **/
    findMany<T extends personaje_tiene_trabajoFindManyArgs>(
      args?: SelectSubset<T, personaje_tiene_trabajoFindManyArgs>
    ): Prisma.PrismaPromise<Array<personaje_tiene_trabajoGetPayload<T>>>

    /**
     * Create a Personaje_tiene_trabajo.
     * @param {personaje_tiene_trabajoCreateArgs} args - Arguments to create a Personaje_tiene_trabajo.
     * @example
     * // Create one Personaje_tiene_trabajo
     * const Personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.create({
     *   data: {
     *     // ... data to create a Personaje_tiene_trabajo
     *   }
     * })
     * 
    **/
    create<T extends personaje_tiene_trabajoCreateArgs>(
      args: SelectSubset<T, personaje_tiene_trabajoCreateArgs>
    ): Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>>

    /**
     * Create many Personaje_tiene_trabajos.
     *     @param {personaje_tiene_trabajoCreateManyArgs} args - Arguments to create many Personaje_tiene_trabajos.
     *     @example
     *     // Create many Personaje_tiene_trabajos
     *     const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends personaje_tiene_trabajoCreateManyArgs>(
      args?: SelectSubset<T, personaje_tiene_trabajoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personaje_tiene_trabajo.
     * @param {personaje_tiene_trabajoDeleteArgs} args - Arguments to delete one Personaje_tiene_trabajo.
     * @example
     * // Delete one Personaje_tiene_trabajo
     * const Personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.delete({
     *   where: {
     *     // ... filter to delete one Personaje_tiene_trabajo
     *   }
     * })
     * 
    **/
    delete<T extends personaje_tiene_trabajoDeleteArgs>(
      args: SelectSubset<T, personaje_tiene_trabajoDeleteArgs>
    ): Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>>

    /**
     * Update one Personaje_tiene_trabajo.
     * @param {personaje_tiene_trabajoUpdateArgs} args - Arguments to update one Personaje_tiene_trabajo.
     * @example
     * // Update one Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends personaje_tiene_trabajoUpdateArgs>(
      args: SelectSubset<T, personaje_tiene_trabajoUpdateArgs>
    ): Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>>

    /**
     * Delete zero or more Personaje_tiene_trabajos.
     * @param {personaje_tiene_trabajoDeleteManyArgs} args - Arguments to filter Personaje_tiene_trabajos to delete.
     * @example
     * // Delete a few Personaje_tiene_trabajos
     * const { count } = await prisma.personaje_tiene_trabajo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends personaje_tiene_trabajoDeleteManyArgs>(
      args?: SelectSubset<T, personaje_tiene_trabajoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personaje_tiene_trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_tiene_trabajoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personaje_tiene_trabajos
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends personaje_tiene_trabajoUpdateManyArgs>(
      args: SelectSubset<T, personaje_tiene_trabajoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personaje_tiene_trabajo.
     * @param {personaje_tiene_trabajoUpsertArgs} args - Arguments to update or create a Personaje_tiene_trabajo.
     * @example
     * // Update or create a Personaje_tiene_trabajo
     * const personaje_tiene_trabajo = await prisma.personaje_tiene_trabajo.upsert({
     *   create: {
     *     // ... data to create a Personaje_tiene_trabajo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personaje_tiene_trabajo we want to update
     *   }
     * })
    **/
    upsert<T extends personaje_tiene_trabajoUpsertArgs>(
      args: SelectSubset<T, personaje_tiene_trabajoUpsertArgs>
    ): Prisma__personaje_tiene_trabajoClient<personaje_tiene_trabajoGetPayload<T>>

    /**
     * Count the number of Personaje_tiene_trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_tiene_trabajoCountArgs} args - Arguments to filter Personaje_tiene_trabajos to count.
     * @example
     * // Count the number of Personaje_tiene_trabajos
     * const count = await prisma.personaje_tiene_trabajo.count({
     *   where: {
     *     // ... the filter for the Personaje_tiene_trabajos we want to count
     *   }
     * })
    **/
    count<T extends personaje_tiene_trabajoCountArgs>(
      args?: Subset<T, personaje_tiene_trabajoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personaje_tiene_trabajoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personaje_tiene_trabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personaje_tiene_trabajoAggregateArgs>(args: Subset<T, Personaje_tiene_trabajoAggregateArgs>): Prisma.PrismaPromise<GetPersonaje_tiene_trabajoAggregateType<T>>

    /**
     * Group by Personaje_tiene_trabajo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_tiene_trabajoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Personaje_tiene_trabajoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Personaje_tiene_trabajoGroupByArgs['orderBy'] }
        : { orderBy?: Personaje_tiene_trabajoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Personaje_tiene_trabajoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaje_tiene_trabajoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for personaje_tiene_trabajo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__personaje_tiene_trabajoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    trabajo<T extends trabajosArgs= {}>(args?: Subset<T, trabajosArgs>): Prisma__trabajosClient<trabajosGetPayload<T> | Null>;

    personaje<T extends personajesArgs= {}>(args?: Subset<T, personajesArgs>): Prisma__personajesClient<personajesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * personaje_tiene_trabajo base type for findUnique actions
   */
  export type personaje_tiene_trabajoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * Filter, which personaje_tiene_trabajo to fetch.
     */
    where: personaje_tiene_trabajoWhereUniqueInput
  }

  /**
   * personaje_tiene_trabajo findUnique
   */
  export interface personaje_tiene_trabajoFindUniqueArgs extends personaje_tiene_trabajoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personaje_tiene_trabajo findUniqueOrThrow
   */
  export type personaje_tiene_trabajoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * Filter, which personaje_tiene_trabajo to fetch.
     */
    where: personaje_tiene_trabajoWhereUniqueInput
  }


  /**
   * personaje_tiene_trabajo base type for findFirst actions
   */
  export type personaje_tiene_trabajoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * Filter, which personaje_tiene_trabajo to fetch.
     */
    where?: personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personaje_tiene_trabajos.
     */
    cursor?: personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_tiene_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personaje_tiene_trabajos.
     */
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }

  /**
   * personaje_tiene_trabajo findFirst
   */
  export interface personaje_tiene_trabajoFindFirstArgs extends personaje_tiene_trabajoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personaje_tiene_trabajo findFirstOrThrow
   */
  export type personaje_tiene_trabajoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * Filter, which personaje_tiene_trabajo to fetch.
     */
    where?: personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personaje_tiene_trabajos.
     */
    cursor?: personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_tiene_trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personaje_tiene_trabajos.
     */
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * personaje_tiene_trabajo findMany
   */
  export type personaje_tiene_trabajoFindManyArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * Filter, which personaje_tiene_trabajos to fetch.
     */
    where?: personaje_tiene_trabajoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_tiene_trabajos to fetch.
     */
    orderBy?: Enumerable<personaje_tiene_trabajoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personaje_tiene_trabajos.
     */
    cursor?: personaje_tiene_trabajoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_tiene_trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_tiene_trabajos.
     */
    skip?: number
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * personaje_tiene_trabajo create
   */
  export type personaje_tiene_trabajoCreateArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * The data needed to create a personaje_tiene_trabajo.
     */
    data: XOR<personaje_tiene_trabajoCreateInput, personaje_tiene_trabajoUncheckedCreateInput>
  }


  /**
   * personaje_tiene_trabajo createMany
   */
  export type personaje_tiene_trabajoCreateManyArgs = {
    /**
     * The data used to create many personaje_tiene_trabajos.
     */
    data: Enumerable<personaje_tiene_trabajoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * personaje_tiene_trabajo update
   */
  export type personaje_tiene_trabajoUpdateArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * The data needed to update a personaje_tiene_trabajo.
     */
    data: XOR<personaje_tiene_trabajoUpdateInput, personaje_tiene_trabajoUncheckedUpdateInput>
    /**
     * Choose, which personaje_tiene_trabajo to update.
     */
    where: personaje_tiene_trabajoWhereUniqueInput
  }


  /**
   * personaje_tiene_trabajo updateMany
   */
  export type personaje_tiene_trabajoUpdateManyArgs = {
    /**
     * The data used to update personaje_tiene_trabajos.
     */
    data: XOR<personaje_tiene_trabajoUpdateManyMutationInput, personaje_tiene_trabajoUncheckedUpdateManyInput>
    /**
     * Filter which personaje_tiene_trabajos to update
     */
    where?: personaje_tiene_trabajoWhereInput
  }


  /**
   * personaje_tiene_trabajo upsert
   */
  export type personaje_tiene_trabajoUpsertArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * The filter to search for the personaje_tiene_trabajo to update in case it exists.
     */
    where: personaje_tiene_trabajoWhereUniqueInput
    /**
     * In case the personaje_tiene_trabajo found by the `where` argument doesn't exist, create a new personaje_tiene_trabajo with this data.
     */
    create: XOR<personaje_tiene_trabajoCreateInput, personaje_tiene_trabajoUncheckedCreateInput>
    /**
     * In case the personaje_tiene_trabajo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personaje_tiene_trabajoUpdateInput, personaje_tiene_trabajoUncheckedUpdateInput>
  }


  /**
   * personaje_tiene_trabajo delete
   */
  export type personaje_tiene_trabajoDeleteArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    /**
     * Filter which personaje_tiene_trabajo to delete.
     */
    where: personaje_tiene_trabajoWhereUniqueInput
  }


  /**
   * personaje_tiene_trabajo deleteMany
   */
  export type personaje_tiene_trabajoDeleteManyArgs = {
    /**
     * Filter which personaje_tiene_trabajos to delete
     */
    where?: personaje_tiene_trabajoWhereInput
  }


  /**
   * personaje_tiene_trabajo without action
   */
  export type personaje_tiene_trabajoArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
  }



  /**
   * Model trabajos
   */


  export type AggregateTrabajos = {
    _count: TrabajosCountAggregateOutputType | null
    _avg: TrabajosAvgAggregateOutputType | null
    _sum: TrabajosSumAggregateOutputType | null
    _min: TrabajosMinAggregateOutputType | null
    _max: TrabajosMaxAggregateOutputType | null
  }

  export type TrabajosAvgAggregateOutputType = {
    id: number | null
    sueldo: number | null
  }

  export type TrabajosSumAggregateOutputType = {
    id: number | null
    sueldo: number | null
  }

  export type TrabajosMinAggregateOutputType = {
    id: number | null
    descripcion: string | null
    sueldo: number | null
  }

  export type TrabajosMaxAggregateOutputType = {
    id: number | null
    descripcion: string | null
    sueldo: number | null
  }

  export type TrabajosCountAggregateOutputType = {
    id: number
    descripcion: number
    sueldo: number
    _all: number
  }


  export type TrabajosAvgAggregateInputType = {
    id?: true
    sueldo?: true
  }

  export type TrabajosSumAggregateInputType = {
    id?: true
    sueldo?: true
  }

  export type TrabajosMinAggregateInputType = {
    id?: true
    descripcion?: true
    sueldo?: true
  }

  export type TrabajosMaxAggregateInputType = {
    id?: true
    descripcion?: true
    sueldo?: true
  }

  export type TrabajosCountAggregateInputType = {
    id?: true
    descripcion?: true
    sueldo?: true
    _all?: true
  }

  export type TrabajosAggregateArgs = {
    /**
     * Filter which trabajos to aggregate.
     */
    where?: trabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trabajos to fetch.
     */
    orderBy?: Enumerable<trabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trabajos
    **/
    _count?: true | TrabajosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrabajosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrabajosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrabajosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrabajosMaxAggregateInputType
  }

  export type GetTrabajosAggregateType<T extends TrabajosAggregateArgs> = {
        [P in keyof T & keyof AggregateTrabajos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrabajos[P]>
      : GetScalarType<T[P], AggregateTrabajos[P]>
  }




  export type TrabajosGroupByArgs = {
    where?: trabajosWhereInput
    orderBy?: Enumerable<trabajosOrderByWithAggregationInput>
    by: TrabajosScalarFieldEnum[]
    having?: trabajosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrabajosCountAggregateInputType | true
    _avg?: TrabajosAvgAggregateInputType
    _sum?: TrabajosSumAggregateInputType
    _min?: TrabajosMinAggregateInputType
    _max?: TrabajosMaxAggregateInputType
  }


  export type TrabajosGroupByOutputType = {
    id: number
    descripcion: string
    sueldo: number
    _count: TrabajosCountAggregateOutputType | null
    _avg: TrabajosAvgAggregateOutputType | null
    _sum: TrabajosSumAggregateOutputType | null
    _min: TrabajosMinAggregateOutputType | null
    _max: TrabajosMaxAggregateOutputType | null
  }

  type GetTrabajosGroupByPayload<T extends TrabajosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TrabajosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrabajosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrabajosGroupByOutputType[P]>
            : GetScalarType<T[P], TrabajosGroupByOutputType[P]>
        }
      >
    >


  export type trabajosSelect = {
    id?: boolean
    descripcion?: boolean
    sueldo?: boolean
    personaje_tiene_trabajo?: boolean | trabajos$personaje_tiene_trabajoArgs
    _count?: boolean | TrabajosCountOutputTypeArgs
  }


  export type trabajosInclude = {
    personaje_tiene_trabajo?: boolean | trabajos$personaje_tiene_trabajoArgs
    _count?: boolean | TrabajosCountOutputTypeArgs
  }

  export type trabajosGetPayload<S extends boolean | null | undefined | trabajosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? trabajos :
    S extends undefined ? never :
    S extends { include: any } & (trabajosArgs | trabajosFindManyArgs)
    ? trabajos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje_tiene_trabajo' ? Array < personaje_tiene_trabajoGetPayload<S['include'][P]>>  :
        P extends '_count' ? TrabajosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (trabajosArgs | trabajosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje_tiene_trabajo' ? Array < personaje_tiene_trabajoGetPayload<S['select'][P]>>  :
        P extends '_count' ? TrabajosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof trabajos ? trabajos[P] : never
  } 
      : trabajos


  type trabajosCountArgs = 
    Omit<trabajosFindManyArgs, 'select' | 'include'> & {
      select?: TrabajosCountAggregateInputType | true
    }

  export interface trabajosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Trabajos that matches the filter.
     * @param {trabajosFindUniqueArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends trabajosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, trabajosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'trabajos'> extends True ? Prisma__trabajosClient<trabajosGetPayload<T>> : Prisma__trabajosClient<trabajosGetPayload<T> | null, null>

    /**
     * Find one Trabajos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {trabajosFindUniqueOrThrowArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends trabajosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, trabajosFindUniqueOrThrowArgs>
    ): Prisma__trabajosClient<trabajosGetPayload<T>>

    /**
     * Find the first Trabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trabajosFindFirstArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends trabajosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, trabajosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'trabajos'> extends True ? Prisma__trabajosClient<trabajosGetPayload<T>> : Prisma__trabajosClient<trabajosGetPayload<T> | null, null>

    /**
     * Find the first Trabajos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trabajosFindFirstOrThrowArgs} args - Arguments to find a Trabajos
     * @example
     * // Get one Trabajos
     * const trabajos = await prisma.trabajos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends trabajosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, trabajosFindFirstOrThrowArgs>
    ): Prisma__trabajosClient<trabajosGetPayload<T>>

    /**
     * Find zero or more Trabajos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trabajosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trabajos
     * const trabajos = await prisma.trabajos.findMany()
     * 
     * // Get first 10 Trabajos
     * const trabajos = await prisma.trabajos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trabajosWithIdOnly = await prisma.trabajos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends trabajosFindManyArgs>(
      args?: SelectSubset<T, trabajosFindManyArgs>
    ): Prisma.PrismaPromise<Array<trabajosGetPayload<T>>>

    /**
     * Create a Trabajos.
     * @param {trabajosCreateArgs} args - Arguments to create a Trabajos.
     * @example
     * // Create one Trabajos
     * const Trabajos = await prisma.trabajos.create({
     *   data: {
     *     // ... data to create a Trabajos
     *   }
     * })
     * 
    **/
    create<T extends trabajosCreateArgs>(
      args: SelectSubset<T, trabajosCreateArgs>
    ): Prisma__trabajosClient<trabajosGetPayload<T>>

    /**
     * Create many Trabajos.
     *     @param {trabajosCreateManyArgs} args - Arguments to create many Trabajos.
     *     @example
     *     // Create many Trabajos
     *     const trabajos = await prisma.trabajos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends trabajosCreateManyArgs>(
      args?: SelectSubset<T, trabajosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trabajos.
     * @param {trabajosDeleteArgs} args - Arguments to delete one Trabajos.
     * @example
     * // Delete one Trabajos
     * const Trabajos = await prisma.trabajos.delete({
     *   where: {
     *     // ... filter to delete one Trabajos
     *   }
     * })
     * 
    **/
    delete<T extends trabajosDeleteArgs>(
      args: SelectSubset<T, trabajosDeleteArgs>
    ): Prisma__trabajosClient<trabajosGetPayload<T>>

    /**
     * Update one Trabajos.
     * @param {trabajosUpdateArgs} args - Arguments to update one Trabajos.
     * @example
     * // Update one Trabajos
     * const trabajos = await prisma.trabajos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends trabajosUpdateArgs>(
      args: SelectSubset<T, trabajosUpdateArgs>
    ): Prisma__trabajosClient<trabajosGetPayload<T>>

    /**
     * Delete zero or more Trabajos.
     * @param {trabajosDeleteManyArgs} args - Arguments to filter Trabajos to delete.
     * @example
     * // Delete a few Trabajos
     * const { count } = await prisma.trabajos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends trabajosDeleteManyArgs>(
      args?: SelectSubset<T, trabajosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trabajosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trabajos
     * const trabajos = await prisma.trabajos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends trabajosUpdateManyArgs>(
      args: SelectSubset<T, trabajosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trabajos.
     * @param {trabajosUpsertArgs} args - Arguments to update or create a Trabajos.
     * @example
     * // Update or create a Trabajos
     * const trabajos = await prisma.trabajos.upsert({
     *   create: {
     *     // ... data to create a Trabajos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trabajos we want to update
     *   }
     * })
    **/
    upsert<T extends trabajosUpsertArgs>(
      args: SelectSubset<T, trabajosUpsertArgs>
    ): Prisma__trabajosClient<trabajosGetPayload<T>>

    /**
     * Count the number of Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trabajosCountArgs} args - Arguments to filter Trabajos to count.
     * @example
     * // Count the number of Trabajos
     * const count = await prisma.trabajos.count({
     *   where: {
     *     // ... the filter for the Trabajos we want to count
     *   }
     * })
    **/
    count<T extends trabajosCountArgs>(
      args?: Subset<T, trabajosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrabajosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrabajosAggregateArgs>(args: Subset<T, TrabajosAggregateArgs>): Prisma.PrismaPromise<GetTrabajosAggregateType<T>>

    /**
     * Group by Trabajos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrabajosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrabajosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrabajosGroupByArgs['orderBy'] }
        : { orderBy?: TrabajosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrabajosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrabajosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for trabajos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__trabajosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje_tiene_trabajo<T extends trabajos$personaje_tiene_trabajoArgs= {}>(args?: Subset<T, trabajos$personaje_tiene_trabajoArgs>): Prisma.PrismaPromise<Array<personaje_tiene_trabajoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * trabajos base type for findUnique actions
   */
  export type trabajosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * Filter, which trabajos to fetch.
     */
    where: trabajosWhereUniqueInput
  }

  /**
   * trabajos findUnique
   */
  export interface trabajosFindUniqueArgs extends trabajosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trabajos findUniqueOrThrow
   */
  export type trabajosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * Filter, which trabajos to fetch.
     */
    where: trabajosWhereUniqueInput
  }


  /**
   * trabajos base type for findFirst actions
   */
  export type trabajosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * Filter, which trabajos to fetch.
     */
    where?: trabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trabajos to fetch.
     */
    orderBy?: Enumerable<trabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trabajos.
     */
    cursor?: trabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trabajos.
     */
    distinct?: Enumerable<TrabajosScalarFieldEnum>
  }

  /**
   * trabajos findFirst
   */
  export interface trabajosFindFirstArgs extends trabajosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * trabajos findFirstOrThrow
   */
  export type trabajosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * Filter, which trabajos to fetch.
     */
    where?: trabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trabajos to fetch.
     */
    orderBy?: Enumerable<trabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trabajos.
     */
    cursor?: trabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trabajos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trabajos.
     */
    distinct?: Enumerable<TrabajosScalarFieldEnum>
  }


  /**
   * trabajos findMany
   */
  export type trabajosFindManyArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * Filter, which trabajos to fetch.
     */
    where?: trabajosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trabajos to fetch.
     */
    orderBy?: Enumerable<trabajosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trabajos.
     */
    cursor?: trabajosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trabajos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trabajos.
     */
    skip?: number
    distinct?: Enumerable<TrabajosScalarFieldEnum>
  }


  /**
   * trabajos create
   */
  export type trabajosCreateArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * The data needed to create a trabajos.
     */
    data: XOR<trabajosCreateInput, trabajosUncheckedCreateInput>
  }


  /**
   * trabajos createMany
   */
  export type trabajosCreateManyArgs = {
    /**
     * The data used to create many trabajos.
     */
    data: Enumerable<trabajosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * trabajos update
   */
  export type trabajosUpdateArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * The data needed to update a trabajos.
     */
    data: XOR<trabajosUpdateInput, trabajosUncheckedUpdateInput>
    /**
     * Choose, which trabajos to update.
     */
    where: trabajosWhereUniqueInput
  }


  /**
   * trabajos updateMany
   */
  export type trabajosUpdateManyArgs = {
    /**
     * The data used to update trabajos.
     */
    data: XOR<trabajosUpdateManyMutationInput, trabajosUncheckedUpdateManyInput>
    /**
     * Filter which trabajos to update
     */
    where?: trabajosWhereInput
  }


  /**
   * trabajos upsert
   */
  export type trabajosUpsertArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * The filter to search for the trabajos to update in case it exists.
     */
    where: trabajosWhereUniqueInput
    /**
     * In case the trabajos found by the `where` argument doesn't exist, create a new trabajos with this data.
     */
    create: XOR<trabajosCreateInput, trabajosUncheckedCreateInput>
    /**
     * In case the trabajos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trabajosUpdateInput, trabajosUncheckedUpdateInput>
  }


  /**
   * trabajos delete
   */
  export type trabajosDeleteArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
    /**
     * Filter which trabajos to delete.
     */
    where: trabajosWhereUniqueInput
  }


  /**
   * trabajos deleteMany
   */
  export type trabajosDeleteManyArgs = {
    /**
     * Filter which trabajos to delete
     */
    where?: trabajosWhereInput
  }


  /**
   * trabajos.personaje_tiene_trabajo
   */
  export type trabajos$personaje_tiene_trabajoArgs = {
    /**
     * Select specific fields to fetch from the personaje_tiene_trabajo
     */
    select?: personaje_tiene_trabajoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_tiene_trabajoInclude | null
    where?: personaje_tiene_trabajoWhereInput
    orderBy?: Enumerable<personaje_tiene_trabajoOrderByWithRelationInput>
    cursor?: personaje_tiene_trabajoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_tiene_trabajoScalarFieldEnum>
  }


  /**
   * trabajos without action
   */
  export type trabajosArgs = {
    /**
     * Select specific fields to fetch from the trabajos
     */
    select?: trabajosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: trabajosInclude | null
  }



  /**
   * Model personaje_habita_reino
   */


  export type AggregatePersonaje_habita_reino = {
    _count: Personaje_habita_reinoCountAggregateOutputType | null
    _avg: Personaje_habita_reinoAvgAggregateOutputType | null
    _sum: Personaje_habita_reinoSumAggregateOutputType | null
    _min: Personaje_habita_reinoMinAggregateOutputType | null
    _max: Personaje_habita_reinoMaxAggregateOutputType | null
  }

  export type Personaje_habita_reinoAvgAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
  }

  export type Personaje_habita_reinoSumAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
  }

  export type Personaje_habita_reinoMinAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
    fecha_registro: Date | null
    es_gobernante: boolean | null
  }

  export type Personaje_habita_reinoMaxAggregateOutputType = {
    id_personaje: number | null
    id_reino: number | null
    fecha_registro: Date | null
    es_gobernante: boolean | null
  }

  export type Personaje_habita_reinoCountAggregateOutputType = {
    id_personaje: number
    id_reino: number
    fecha_registro: number
    es_gobernante: number
    _all: number
  }


  export type Personaje_habita_reinoAvgAggregateInputType = {
    id_personaje?: true
    id_reino?: true
  }

  export type Personaje_habita_reinoSumAggregateInputType = {
    id_personaje?: true
    id_reino?: true
  }

  export type Personaje_habita_reinoMinAggregateInputType = {
    id_personaje?: true
    id_reino?: true
    fecha_registro?: true
    es_gobernante?: true
  }

  export type Personaje_habita_reinoMaxAggregateInputType = {
    id_personaje?: true
    id_reino?: true
    fecha_registro?: true
    es_gobernante?: true
  }

  export type Personaje_habita_reinoCountAggregateInputType = {
    id_personaje?: true
    id_reino?: true
    fecha_registro?: true
    es_gobernante?: true
    _all?: true
  }

  export type Personaje_habita_reinoAggregateArgs = {
    /**
     * Filter which personaje_habita_reino to aggregate.
     */
    where?: personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_habita_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personaje_habita_reinos
    **/
    _count?: true | Personaje_habita_reinoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Personaje_habita_reinoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Personaje_habita_reinoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Personaje_habita_reinoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Personaje_habita_reinoMaxAggregateInputType
  }

  export type GetPersonaje_habita_reinoAggregateType<T extends Personaje_habita_reinoAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonaje_habita_reino]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonaje_habita_reino[P]>
      : GetScalarType<T[P], AggregatePersonaje_habita_reino[P]>
  }




  export type Personaje_habita_reinoGroupByArgs = {
    where?: personaje_habita_reinoWhereInput
    orderBy?: Enumerable<personaje_habita_reinoOrderByWithAggregationInput>
    by: Personaje_habita_reinoScalarFieldEnum[]
    having?: personaje_habita_reinoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Personaje_habita_reinoCountAggregateInputType | true
    _avg?: Personaje_habita_reinoAvgAggregateInputType
    _sum?: Personaje_habita_reinoSumAggregateInputType
    _min?: Personaje_habita_reinoMinAggregateInputType
    _max?: Personaje_habita_reinoMaxAggregateInputType
  }


  export type Personaje_habita_reinoGroupByOutputType = {
    id_personaje: number
    id_reino: number
    fecha_registro: Date
    es_gobernante: boolean
    _count: Personaje_habita_reinoCountAggregateOutputType | null
    _avg: Personaje_habita_reinoAvgAggregateOutputType | null
    _sum: Personaje_habita_reinoSumAggregateOutputType | null
    _min: Personaje_habita_reinoMinAggregateOutputType | null
    _max: Personaje_habita_reinoMaxAggregateOutputType | null
  }

  type GetPersonaje_habita_reinoGroupByPayload<T extends Personaje_habita_reinoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Personaje_habita_reinoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Personaje_habita_reinoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Personaje_habita_reinoGroupByOutputType[P]>
            : GetScalarType<T[P], Personaje_habita_reinoGroupByOutputType[P]>
        }
      >
    >


  export type personaje_habita_reinoSelect = {
    id_personaje?: boolean
    id_reino?: boolean
    fecha_registro?: boolean
    es_gobernante?: boolean
    personaje?: boolean | personajesArgs
    reino?: boolean | reinosArgs
  }


  export type personaje_habita_reinoInclude = {
    personaje?: boolean | personajesArgs
    reino?: boolean | reinosArgs
  }

  export type personaje_habita_reinoGetPayload<S extends boolean | null | undefined | personaje_habita_reinoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? personaje_habita_reino :
    S extends undefined ? never :
    S extends { include: any } & (personaje_habita_reinoArgs | personaje_habita_reinoFindManyArgs)
    ? personaje_habita_reino  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje' ? personajesGetPayload<S['include'][P]> :
        P extends 'reino' ? reinosGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (personaje_habita_reinoArgs | personaje_habita_reinoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje' ? personajesGetPayload<S['select'][P]> :
        P extends 'reino' ? reinosGetPayload<S['select'][P]> :  P extends keyof personaje_habita_reino ? personaje_habita_reino[P] : never
  } 
      : personaje_habita_reino


  type personaje_habita_reinoCountArgs = 
    Omit<personaje_habita_reinoFindManyArgs, 'select' | 'include'> & {
      select?: Personaje_habita_reinoCountAggregateInputType | true
    }

  export interface personaje_habita_reinoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personaje_habita_reino that matches the filter.
     * @param {personaje_habita_reinoFindUniqueArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends personaje_habita_reinoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, personaje_habita_reinoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'personaje_habita_reino'> extends True ? Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>> : Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T> | null, null>

    /**
     * Find one Personaje_habita_reino that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {personaje_habita_reinoFindUniqueOrThrowArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends personaje_habita_reinoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, personaje_habita_reinoFindUniqueOrThrowArgs>
    ): Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>>

    /**
     * Find the first Personaje_habita_reino that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_habita_reinoFindFirstArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends personaje_habita_reinoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, personaje_habita_reinoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'personaje_habita_reino'> extends True ? Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>> : Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T> | null, null>

    /**
     * Find the first Personaje_habita_reino that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_habita_reinoFindFirstOrThrowArgs} args - Arguments to find a Personaje_habita_reino
     * @example
     * // Get one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends personaje_habita_reinoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, personaje_habita_reinoFindFirstOrThrowArgs>
    ): Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>>

    /**
     * Find zero or more Personaje_habita_reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_habita_reinoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personaje_habita_reinos
     * const personaje_habita_reinos = await prisma.personaje_habita_reino.findMany()
     * 
     * // Get first 10 Personaje_habita_reinos
     * const personaje_habita_reinos = await prisma.personaje_habita_reino.findMany({ take: 10 })
     * 
     * // Only select the `id_personaje`
     * const personaje_habita_reinoWithId_personajeOnly = await prisma.personaje_habita_reino.findMany({ select: { id_personaje: true } })
     * 
    **/
    findMany<T extends personaje_habita_reinoFindManyArgs>(
      args?: SelectSubset<T, personaje_habita_reinoFindManyArgs>
    ): Prisma.PrismaPromise<Array<personaje_habita_reinoGetPayload<T>>>

    /**
     * Create a Personaje_habita_reino.
     * @param {personaje_habita_reinoCreateArgs} args - Arguments to create a Personaje_habita_reino.
     * @example
     * // Create one Personaje_habita_reino
     * const Personaje_habita_reino = await prisma.personaje_habita_reino.create({
     *   data: {
     *     // ... data to create a Personaje_habita_reino
     *   }
     * })
     * 
    **/
    create<T extends personaje_habita_reinoCreateArgs>(
      args: SelectSubset<T, personaje_habita_reinoCreateArgs>
    ): Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>>

    /**
     * Create many Personaje_habita_reinos.
     *     @param {personaje_habita_reinoCreateManyArgs} args - Arguments to create many Personaje_habita_reinos.
     *     @example
     *     // Create many Personaje_habita_reinos
     *     const personaje_habita_reino = await prisma.personaje_habita_reino.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends personaje_habita_reinoCreateManyArgs>(
      args?: SelectSubset<T, personaje_habita_reinoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personaje_habita_reino.
     * @param {personaje_habita_reinoDeleteArgs} args - Arguments to delete one Personaje_habita_reino.
     * @example
     * // Delete one Personaje_habita_reino
     * const Personaje_habita_reino = await prisma.personaje_habita_reino.delete({
     *   where: {
     *     // ... filter to delete one Personaje_habita_reino
     *   }
     * })
     * 
    **/
    delete<T extends personaje_habita_reinoDeleteArgs>(
      args: SelectSubset<T, personaje_habita_reinoDeleteArgs>
    ): Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>>

    /**
     * Update one Personaje_habita_reino.
     * @param {personaje_habita_reinoUpdateArgs} args - Arguments to update one Personaje_habita_reino.
     * @example
     * // Update one Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends personaje_habita_reinoUpdateArgs>(
      args: SelectSubset<T, personaje_habita_reinoUpdateArgs>
    ): Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>>

    /**
     * Delete zero or more Personaje_habita_reinos.
     * @param {personaje_habita_reinoDeleteManyArgs} args - Arguments to filter Personaje_habita_reinos to delete.
     * @example
     * // Delete a few Personaje_habita_reinos
     * const { count } = await prisma.personaje_habita_reino.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends personaje_habita_reinoDeleteManyArgs>(
      args?: SelectSubset<T, personaje_habita_reinoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personaje_habita_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_habita_reinoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personaje_habita_reinos
     * const personaje_habita_reino = await prisma.personaje_habita_reino.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends personaje_habita_reinoUpdateManyArgs>(
      args: SelectSubset<T, personaje_habita_reinoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personaje_habita_reino.
     * @param {personaje_habita_reinoUpsertArgs} args - Arguments to update or create a Personaje_habita_reino.
     * @example
     * // Update or create a Personaje_habita_reino
     * const personaje_habita_reino = await prisma.personaje_habita_reino.upsert({
     *   create: {
     *     // ... data to create a Personaje_habita_reino
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personaje_habita_reino we want to update
     *   }
     * })
    **/
    upsert<T extends personaje_habita_reinoUpsertArgs>(
      args: SelectSubset<T, personaje_habita_reinoUpsertArgs>
    ): Prisma__personaje_habita_reinoClient<personaje_habita_reinoGetPayload<T>>

    /**
     * Count the number of Personaje_habita_reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personaje_habita_reinoCountArgs} args - Arguments to filter Personaje_habita_reinos to count.
     * @example
     * // Count the number of Personaje_habita_reinos
     * const count = await prisma.personaje_habita_reino.count({
     *   where: {
     *     // ... the filter for the Personaje_habita_reinos we want to count
     *   }
     * })
    **/
    count<T extends personaje_habita_reinoCountArgs>(
      args?: Subset<T, personaje_habita_reinoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Personaje_habita_reinoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personaje_habita_reino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Personaje_habita_reinoAggregateArgs>(args: Subset<T, Personaje_habita_reinoAggregateArgs>): Prisma.PrismaPromise<GetPersonaje_habita_reinoAggregateType<T>>

    /**
     * Group by Personaje_habita_reino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Personaje_habita_reinoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Personaje_habita_reinoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Personaje_habita_reinoGroupByArgs['orderBy'] }
        : { orderBy?: Personaje_habita_reinoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Personaje_habita_reinoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaje_habita_reinoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for personaje_habita_reino.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__personaje_habita_reinoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje<T extends personajesArgs= {}>(args?: Subset<T, personajesArgs>): Prisma__personajesClient<personajesGetPayload<T> | Null>;

    reino<T extends reinosArgs= {}>(args?: Subset<T, reinosArgs>): Prisma__reinosClient<reinosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * personaje_habita_reino base type for findUnique actions
   */
  export type personaje_habita_reinoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * Filter, which personaje_habita_reino to fetch.
     */
    where: personaje_habita_reinoWhereUniqueInput
  }

  /**
   * personaje_habita_reino findUnique
   */
  export interface personaje_habita_reinoFindUniqueArgs extends personaje_habita_reinoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personaje_habita_reino findUniqueOrThrow
   */
  export type personaje_habita_reinoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * Filter, which personaje_habita_reino to fetch.
     */
    where: personaje_habita_reinoWhereUniqueInput
  }


  /**
   * personaje_habita_reino base type for findFirst actions
   */
  export type personaje_habita_reinoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * Filter, which personaje_habita_reino to fetch.
     */
    where?: personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personaje_habita_reinos.
     */
    cursor?: personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_habita_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personaje_habita_reinos.
     */
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }

  /**
   * personaje_habita_reino findFirst
   */
  export interface personaje_habita_reinoFindFirstArgs extends personaje_habita_reinoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * personaje_habita_reino findFirstOrThrow
   */
  export type personaje_habita_reinoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * Filter, which personaje_habita_reino to fetch.
     */
    where?: personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personaje_habita_reinos.
     */
    cursor?: personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_habita_reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personaje_habita_reinos.
     */
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * personaje_habita_reino findMany
   */
  export type personaje_habita_reinoFindManyArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * Filter, which personaje_habita_reinos to fetch.
     */
    where?: personaje_habita_reinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personaje_habita_reinos to fetch.
     */
    orderBy?: Enumerable<personaje_habita_reinoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personaje_habita_reinos.
     */
    cursor?: personaje_habita_reinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personaje_habita_reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personaje_habita_reinos.
     */
    skip?: number
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * personaje_habita_reino create
   */
  export type personaje_habita_reinoCreateArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * The data needed to create a personaje_habita_reino.
     */
    data: XOR<personaje_habita_reinoCreateInput, personaje_habita_reinoUncheckedCreateInput>
  }


  /**
   * personaje_habita_reino createMany
   */
  export type personaje_habita_reinoCreateManyArgs = {
    /**
     * The data used to create many personaje_habita_reinos.
     */
    data: Enumerable<personaje_habita_reinoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * personaje_habita_reino update
   */
  export type personaje_habita_reinoUpdateArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * The data needed to update a personaje_habita_reino.
     */
    data: XOR<personaje_habita_reinoUpdateInput, personaje_habita_reinoUncheckedUpdateInput>
    /**
     * Choose, which personaje_habita_reino to update.
     */
    where: personaje_habita_reinoWhereUniqueInput
  }


  /**
   * personaje_habita_reino updateMany
   */
  export type personaje_habita_reinoUpdateManyArgs = {
    /**
     * The data used to update personaje_habita_reinos.
     */
    data: XOR<personaje_habita_reinoUpdateManyMutationInput, personaje_habita_reinoUncheckedUpdateManyInput>
    /**
     * Filter which personaje_habita_reinos to update
     */
    where?: personaje_habita_reinoWhereInput
  }


  /**
   * personaje_habita_reino upsert
   */
  export type personaje_habita_reinoUpsertArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * The filter to search for the personaje_habita_reino to update in case it exists.
     */
    where: personaje_habita_reinoWhereUniqueInput
    /**
     * In case the personaje_habita_reino found by the `where` argument doesn't exist, create a new personaje_habita_reino with this data.
     */
    create: XOR<personaje_habita_reinoCreateInput, personaje_habita_reinoUncheckedCreateInput>
    /**
     * In case the personaje_habita_reino was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personaje_habita_reinoUpdateInput, personaje_habita_reinoUncheckedUpdateInput>
  }


  /**
   * personaje_habita_reino delete
   */
  export type personaje_habita_reinoDeleteArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    /**
     * Filter which personaje_habita_reino to delete.
     */
    where: personaje_habita_reinoWhereUniqueInput
  }


  /**
   * personaje_habita_reino deleteMany
   */
  export type personaje_habita_reinoDeleteManyArgs = {
    /**
     * Filter which personaje_habita_reinos to delete
     */
    where?: personaje_habita_reinoWhereInput
  }


  /**
   * personaje_habita_reino without action
   */
  export type personaje_habita_reinoArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
  }



  /**
   * Model reinos
   */


  export type AggregateReinos = {
    _count: ReinosCountAggregateOutputType | null
    _avg: ReinosAvgAggregateOutputType | null
    _sum: ReinosSumAggregateOutputType | null
    _min: ReinosMinAggregateOutputType | null
    _max: ReinosMaxAggregateOutputType | null
  }

  export type ReinosAvgAggregateOutputType = {
    id: number | null
    superficie: number | null
  }

  export type ReinosSumAggregateOutputType = {
    id: number | null
    superficie: number | null
  }

  export type ReinosMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    ubicacion: string | null
    superficie: number | null
  }

  export type ReinosMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    ubicacion: string | null
    superficie: number | null
  }

  export type ReinosCountAggregateOutputType = {
    id: number
    nombre: number
    ubicacion: number
    superficie: number
    _all: number
  }


  export type ReinosAvgAggregateInputType = {
    id?: true
    superficie?: true
  }

  export type ReinosSumAggregateInputType = {
    id?: true
    superficie?: true
  }

  export type ReinosMinAggregateInputType = {
    id?: true
    nombre?: true
    ubicacion?: true
    superficie?: true
  }

  export type ReinosMaxAggregateInputType = {
    id?: true
    nombre?: true
    ubicacion?: true
    superficie?: true
  }

  export type ReinosCountAggregateInputType = {
    id?: true
    nombre?: true
    ubicacion?: true
    superficie?: true
    _all?: true
  }

  export type ReinosAggregateArgs = {
    /**
     * Filter which reinos to aggregate.
     */
    where?: reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reinos to fetch.
     */
    orderBy?: Enumerable<reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reinos
    **/
    _count?: true | ReinosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReinosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReinosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReinosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReinosMaxAggregateInputType
  }

  export type GetReinosAggregateType<T extends ReinosAggregateArgs> = {
        [P in keyof T & keyof AggregateReinos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReinos[P]>
      : GetScalarType<T[P], AggregateReinos[P]>
  }




  export type ReinosGroupByArgs = {
    where?: reinosWhereInput
    orderBy?: Enumerable<reinosOrderByWithAggregationInput>
    by: ReinosScalarFieldEnum[]
    having?: reinosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReinosCountAggregateInputType | true
    _avg?: ReinosAvgAggregateInputType
    _sum?: ReinosSumAggregateInputType
    _min?: ReinosMinAggregateInputType
    _max?: ReinosMaxAggregateInputType
  }


  export type ReinosGroupByOutputType = {
    id: number
    nombre: string
    ubicacion: string
    superficie: number
    _count: ReinosCountAggregateOutputType | null
    _avg: ReinosAvgAggregateOutputType | null
    _sum: ReinosSumAggregateOutputType | null
    _min: ReinosMinAggregateOutputType | null
    _max: ReinosMaxAggregateOutputType | null
  }

  type GetReinosGroupByPayload<T extends ReinosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReinosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReinosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReinosGroupByOutputType[P]>
            : GetScalarType<T[P], ReinosGroupByOutputType[P]>
        }
      >
    >


  export type reinosSelect = {
    id?: boolean
    nombre?: boolean
    ubicacion?: boolean
    superficie?: boolean
    personaje_habita_reino?: boolean | reinos$personaje_habita_reinoArgs
    diplomaciasAsociadas1?: boolean | reinos$diplomaciasAsociadas1Args
    diplomaciasAsociadas2?: boolean | reinos$diplomaciasAsociadas2Args
    reino_defensas?: boolean | reinos$reino_defensasArgs
    _count?: boolean | ReinosCountOutputTypeArgs
  }


  export type reinosInclude = {
    personaje_habita_reino?: boolean | reinos$personaje_habita_reinoArgs
    diplomaciasAsociadas1?: boolean | reinos$diplomaciasAsociadas1Args
    diplomaciasAsociadas2?: boolean | reinos$diplomaciasAsociadas2Args
    reino_defensas?: boolean | reinos$reino_defensasArgs
    _count?: boolean | ReinosCountOutputTypeArgs
  }

  export type reinosGetPayload<S extends boolean | null | undefined | reinosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reinos :
    S extends undefined ? never :
    S extends { include: any } & (reinosArgs | reinosFindManyArgs)
    ? reinos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personaje_habita_reino' ? Array < personaje_habita_reinoGetPayload<S['include'][P]>>  :
        P extends 'diplomaciasAsociadas1' ? Array < diplomaciasGetPayload<S['include'][P]>>  :
        P extends 'diplomaciasAsociadas2' ? Array < diplomaciasGetPayload<S['include'][P]>>  :
        P extends 'reino_defensas' ? Array < reino_defensasGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReinosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (reinosArgs | reinosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personaje_habita_reino' ? Array < personaje_habita_reinoGetPayload<S['select'][P]>>  :
        P extends 'diplomaciasAsociadas1' ? Array < diplomaciasGetPayload<S['select'][P]>>  :
        P extends 'diplomaciasAsociadas2' ? Array < diplomaciasGetPayload<S['select'][P]>>  :
        P extends 'reino_defensas' ? Array < reino_defensasGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReinosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof reinos ? reinos[P] : never
  } 
      : reinos


  type reinosCountArgs = 
    Omit<reinosFindManyArgs, 'select' | 'include'> & {
      select?: ReinosCountAggregateInputType | true
    }

  export interface reinosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reinos that matches the filter.
     * @param {reinosFindUniqueArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reinosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reinosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reinos'> extends True ? Prisma__reinosClient<reinosGetPayload<T>> : Prisma__reinosClient<reinosGetPayload<T> | null, null>

    /**
     * Find one Reinos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reinosFindUniqueOrThrowArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reinosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reinosFindUniqueOrThrowArgs>
    ): Prisma__reinosClient<reinosGetPayload<T>>

    /**
     * Find the first Reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reinosFindFirstArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reinosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reinosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reinos'> extends True ? Prisma__reinosClient<reinosGetPayload<T>> : Prisma__reinosClient<reinosGetPayload<T> | null, null>

    /**
     * Find the first Reinos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reinosFindFirstOrThrowArgs} args - Arguments to find a Reinos
     * @example
     * // Get one Reinos
     * const reinos = await prisma.reinos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reinosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reinosFindFirstOrThrowArgs>
    ): Prisma__reinosClient<reinosGetPayload<T>>

    /**
     * Find zero or more Reinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reinosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reinos
     * const reinos = await prisma.reinos.findMany()
     * 
     * // Get first 10 Reinos
     * const reinos = await prisma.reinos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reinosWithIdOnly = await prisma.reinos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reinosFindManyArgs>(
      args?: SelectSubset<T, reinosFindManyArgs>
    ): Prisma.PrismaPromise<Array<reinosGetPayload<T>>>

    /**
     * Create a Reinos.
     * @param {reinosCreateArgs} args - Arguments to create a Reinos.
     * @example
     * // Create one Reinos
     * const Reinos = await prisma.reinos.create({
     *   data: {
     *     // ... data to create a Reinos
     *   }
     * })
     * 
    **/
    create<T extends reinosCreateArgs>(
      args: SelectSubset<T, reinosCreateArgs>
    ): Prisma__reinosClient<reinosGetPayload<T>>

    /**
     * Create many Reinos.
     *     @param {reinosCreateManyArgs} args - Arguments to create many Reinos.
     *     @example
     *     // Create many Reinos
     *     const reinos = await prisma.reinos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reinosCreateManyArgs>(
      args?: SelectSubset<T, reinosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reinos.
     * @param {reinosDeleteArgs} args - Arguments to delete one Reinos.
     * @example
     * // Delete one Reinos
     * const Reinos = await prisma.reinos.delete({
     *   where: {
     *     // ... filter to delete one Reinos
     *   }
     * })
     * 
    **/
    delete<T extends reinosDeleteArgs>(
      args: SelectSubset<T, reinosDeleteArgs>
    ): Prisma__reinosClient<reinosGetPayload<T>>

    /**
     * Update one Reinos.
     * @param {reinosUpdateArgs} args - Arguments to update one Reinos.
     * @example
     * // Update one Reinos
     * const reinos = await prisma.reinos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reinosUpdateArgs>(
      args: SelectSubset<T, reinosUpdateArgs>
    ): Prisma__reinosClient<reinosGetPayload<T>>

    /**
     * Delete zero or more Reinos.
     * @param {reinosDeleteManyArgs} args - Arguments to filter Reinos to delete.
     * @example
     * // Delete a few Reinos
     * const { count } = await prisma.reinos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reinosDeleteManyArgs>(
      args?: SelectSubset<T, reinosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reinosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reinos
     * const reinos = await prisma.reinos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reinosUpdateManyArgs>(
      args: SelectSubset<T, reinosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reinos.
     * @param {reinosUpsertArgs} args - Arguments to update or create a Reinos.
     * @example
     * // Update or create a Reinos
     * const reinos = await prisma.reinos.upsert({
     *   create: {
     *     // ... data to create a Reinos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reinos we want to update
     *   }
     * })
    **/
    upsert<T extends reinosUpsertArgs>(
      args: SelectSubset<T, reinosUpsertArgs>
    ): Prisma__reinosClient<reinosGetPayload<T>>

    /**
     * Count the number of Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reinosCountArgs} args - Arguments to filter Reinos to count.
     * @example
     * // Count the number of Reinos
     * const count = await prisma.reinos.count({
     *   where: {
     *     // ... the filter for the Reinos we want to count
     *   }
     * })
    **/
    count<T extends reinosCountArgs>(
      args?: Subset<T, reinosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReinosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReinosAggregateArgs>(args: Subset<T, ReinosAggregateArgs>): Prisma.PrismaPromise<GetReinosAggregateType<T>>

    /**
     * Group by Reinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReinosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReinosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReinosGroupByArgs['orderBy'] }
        : { orderBy?: ReinosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReinosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReinosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reinos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reinosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personaje_habita_reino<T extends reinos$personaje_habita_reinoArgs= {}>(args?: Subset<T, reinos$personaje_habita_reinoArgs>): Prisma.PrismaPromise<Array<personaje_habita_reinoGetPayload<T>>| Null>;

    diplomaciasAsociadas1<T extends reinos$diplomaciasAsociadas1Args= {}>(args?: Subset<T, reinos$diplomaciasAsociadas1Args>): Prisma.PrismaPromise<Array<diplomaciasGetPayload<T>>| Null>;

    diplomaciasAsociadas2<T extends reinos$diplomaciasAsociadas2Args= {}>(args?: Subset<T, reinos$diplomaciasAsociadas2Args>): Prisma.PrismaPromise<Array<diplomaciasGetPayload<T>>| Null>;

    reino_defensas<T extends reinos$reino_defensasArgs= {}>(args?: Subset<T, reinos$reino_defensasArgs>): Prisma.PrismaPromise<Array<reino_defensasGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reinos base type for findUnique actions
   */
  export type reinosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * Filter, which reinos to fetch.
     */
    where: reinosWhereUniqueInput
  }

  /**
   * reinos findUnique
   */
  export interface reinosFindUniqueArgs extends reinosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reinos findUniqueOrThrow
   */
  export type reinosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * Filter, which reinos to fetch.
     */
    where: reinosWhereUniqueInput
  }


  /**
   * reinos base type for findFirst actions
   */
  export type reinosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * Filter, which reinos to fetch.
     */
    where?: reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reinos to fetch.
     */
    orderBy?: Enumerable<reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reinos.
     */
    cursor?: reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reinos.
     */
    distinct?: Enumerable<ReinosScalarFieldEnum>
  }

  /**
   * reinos findFirst
   */
  export interface reinosFindFirstArgs extends reinosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reinos findFirstOrThrow
   */
  export type reinosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * Filter, which reinos to fetch.
     */
    where?: reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reinos to fetch.
     */
    orderBy?: Enumerable<reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reinos.
     */
    cursor?: reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reinos.
     */
    distinct?: Enumerable<ReinosScalarFieldEnum>
  }


  /**
   * reinos findMany
   */
  export type reinosFindManyArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * Filter, which reinos to fetch.
     */
    where?: reinosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reinos to fetch.
     */
    orderBy?: Enumerable<reinosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reinos.
     */
    cursor?: reinosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reinos.
     */
    skip?: number
    distinct?: Enumerable<ReinosScalarFieldEnum>
  }


  /**
   * reinos create
   */
  export type reinosCreateArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * The data needed to create a reinos.
     */
    data: XOR<reinosCreateInput, reinosUncheckedCreateInput>
  }


  /**
   * reinos createMany
   */
  export type reinosCreateManyArgs = {
    /**
     * The data used to create many reinos.
     */
    data: Enumerable<reinosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reinos update
   */
  export type reinosUpdateArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * The data needed to update a reinos.
     */
    data: XOR<reinosUpdateInput, reinosUncheckedUpdateInput>
    /**
     * Choose, which reinos to update.
     */
    where: reinosWhereUniqueInput
  }


  /**
   * reinos updateMany
   */
  export type reinosUpdateManyArgs = {
    /**
     * The data used to update reinos.
     */
    data: XOR<reinosUpdateManyMutationInput, reinosUncheckedUpdateManyInput>
    /**
     * Filter which reinos to update
     */
    where?: reinosWhereInput
  }


  /**
   * reinos upsert
   */
  export type reinosUpsertArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * The filter to search for the reinos to update in case it exists.
     */
    where: reinosWhereUniqueInput
    /**
     * In case the reinos found by the `where` argument doesn't exist, create a new reinos with this data.
     */
    create: XOR<reinosCreateInput, reinosUncheckedCreateInput>
    /**
     * In case the reinos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reinosUpdateInput, reinosUncheckedUpdateInput>
  }


  /**
   * reinos delete
   */
  export type reinosDeleteArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
    /**
     * Filter which reinos to delete.
     */
    where: reinosWhereUniqueInput
  }


  /**
   * reinos deleteMany
   */
  export type reinosDeleteManyArgs = {
    /**
     * Filter which reinos to delete
     */
    where?: reinosWhereInput
  }


  /**
   * reinos.personaje_habita_reino
   */
  export type reinos$personaje_habita_reinoArgs = {
    /**
     * Select specific fields to fetch from the personaje_habita_reino
     */
    select?: personaje_habita_reinoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: personaje_habita_reinoInclude | null
    where?: personaje_habita_reinoWhereInput
    orderBy?: Enumerable<personaje_habita_reinoOrderByWithRelationInput>
    cursor?: personaje_habita_reinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Personaje_habita_reinoScalarFieldEnum>
  }


  /**
   * reinos.diplomaciasAsociadas1
   */
  export type reinos$diplomaciasAsociadas1Args = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    where?: diplomaciasWhereInput
    orderBy?: Enumerable<diplomaciasOrderByWithRelationInput>
    cursor?: diplomaciasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * reinos.diplomaciasAsociadas2
   */
  export type reinos$diplomaciasAsociadas2Args = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    where?: diplomaciasWhereInput
    orderBy?: Enumerable<diplomaciasOrderByWithRelationInput>
    cursor?: diplomaciasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * reinos.reino_defensas
   */
  export type reinos$reino_defensasArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    where?: reino_defensasWhereInput
    orderBy?: Enumerable<reino_defensasOrderByWithRelationInput>
    cursor?: reino_defensasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Reino_defensasScalarFieldEnum>
  }


  /**
   * reinos without action
   */
  export type reinosArgs = {
    /**
     * Select specific fields to fetch from the reinos
     */
    select?: reinosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reinosInclude | null
  }



  /**
   * Model defensas
   */


  export type AggregateDefensas = {
    _count: DefensasCountAggregateOutputType | null
    _avg: DefensasAvgAggregateOutputType | null
    _sum: DefensasSumAggregateOutputType | null
    _min: DefensasMinAggregateOutputType | null
    _max: DefensasMaxAggregateOutputType | null
  }

  export type DefensasAvgAggregateOutputType = {
    id: number | null
  }

  export type DefensasSumAggregateOutputType = {
    id: number | null
  }

  export type DefensasMinAggregateOutputType = {
    id: number | null
    defensa: string | null
  }

  export type DefensasMaxAggregateOutputType = {
    id: number | null
    defensa: string | null
  }

  export type DefensasCountAggregateOutputType = {
    id: number
    defensa: number
    _all: number
  }


  export type DefensasAvgAggregateInputType = {
    id?: true
  }

  export type DefensasSumAggregateInputType = {
    id?: true
  }

  export type DefensasMinAggregateInputType = {
    id?: true
    defensa?: true
  }

  export type DefensasMaxAggregateInputType = {
    id?: true
    defensa?: true
  }

  export type DefensasCountAggregateInputType = {
    id?: true
    defensa?: true
    _all?: true
  }

  export type DefensasAggregateArgs = {
    /**
     * Filter which defensas to aggregate.
     */
    where?: defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defensas to fetch.
     */
    orderBy?: Enumerable<defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned defensas
    **/
    _count?: true | DefensasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DefensasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DefensasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DefensasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DefensasMaxAggregateInputType
  }

  export type GetDefensasAggregateType<T extends DefensasAggregateArgs> = {
        [P in keyof T & keyof AggregateDefensas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDefensas[P]>
      : GetScalarType<T[P], AggregateDefensas[P]>
  }




  export type DefensasGroupByArgs = {
    where?: defensasWhereInput
    orderBy?: Enumerable<defensasOrderByWithAggregationInput>
    by: DefensasScalarFieldEnum[]
    having?: defensasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DefensasCountAggregateInputType | true
    _avg?: DefensasAvgAggregateInputType
    _sum?: DefensasSumAggregateInputType
    _min?: DefensasMinAggregateInputType
    _max?: DefensasMaxAggregateInputType
  }


  export type DefensasGroupByOutputType = {
    id: number
    defensa: string
    _count: DefensasCountAggregateOutputType | null
    _avg: DefensasAvgAggregateOutputType | null
    _sum: DefensasSumAggregateOutputType | null
    _min: DefensasMinAggregateOutputType | null
    _max: DefensasMaxAggregateOutputType | null
  }

  type GetDefensasGroupByPayload<T extends DefensasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DefensasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DefensasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DefensasGroupByOutputType[P]>
            : GetScalarType<T[P], DefensasGroupByOutputType[P]>
        }
      >
    >


  export type defensasSelect = {
    id?: boolean
    defensa?: boolean
    reino_defensas?: boolean | defensas$reino_defensasArgs
    _count?: boolean | DefensasCountOutputTypeArgs
  }


  export type defensasInclude = {
    reino_defensas?: boolean | defensas$reino_defensasArgs
    _count?: boolean | DefensasCountOutputTypeArgs
  }

  export type defensasGetPayload<S extends boolean | null | undefined | defensasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? defensas :
    S extends undefined ? never :
    S extends { include: any } & (defensasArgs | defensasFindManyArgs)
    ? defensas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reino_defensas' ? Array < reino_defensasGetPayload<S['include'][P]>>  :
        P extends '_count' ? DefensasCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (defensasArgs | defensasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reino_defensas' ? Array < reino_defensasGetPayload<S['select'][P]>>  :
        P extends '_count' ? DefensasCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof defensas ? defensas[P] : never
  } 
      : defensas


  type defensasCountArgs = 
    Omit<defensasFindManyArgs, 'select' | 'include'> & {
      select?: DefensasCountAggregateInputType | true
    }

  export interface defensasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Defensas that matches the filter.
     * @param {defensasFindUniqueArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends defensasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, defensasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'defensas'> extends True ? Prisma__defensasClient<defensasGetPayload<T>> : Prisma__defensasClient<defensasGetPayload<T> | null, null>

    /**
     * Find one Defensas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {defensasFindUniqueOrThrowArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends defensasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, defensasFindUniqueOrThrowArgs>
    ): Prisma__defensasClient<defensasGetPayload<T>>

    /**
     * Find the first Defensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defensasFindFirstArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends defensasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, defensasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'defensas'> extends True ? Prisma__defensasClient<defensasGetPayload<T>> : Prisma__defensasClient<defensasGetPayload<T> | null, null>

    /**
     * Find the first Defensas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defensasFindFirstOrThrowArgs} args - Arguments to find a Defensas
     * @example
     * // Get one Defensas
     * const defensas = await prisma.defensas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends defensasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, defensasFindFirstOrThrowArgs>
    ): Prisma__defensasClient<defensasGetPayload<T>>

    /**
     * Find zero or more Defensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defensasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Defensas
     * const defensas = await prisma.defensas.findMany()
     * 
     * // Get first 10 Defensas
     * const defensas = await prisma.defensas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const defensasWithIdOnly = await prisma.defensas.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends defensasFindManyArgs>(
      args?: SelectSubset<T, defensasFindManyArgs>
    ): Prisma.PrismaPromise<Array<defensasGetPayload<T>>>

    /**
     * Create a Defensas.
     * @param {defensasCreateArgs} args - Arguments to create a Defensas.
     * @example
     * // Create one Defensas
     * const Defensas = await prisma.defensas.create({
     *   data: {
     *     // ... data to create a Defensas
     *   }
     * })
     * 
    **/
    create<T extends defensasCreateArgs>(
      args: SelectSubset<T, defensasCreateArgs>
    ): Prisma__defensasClient<defensasGetPayload<T>>

    /**
     * Create many Defensas.
     *     @param {defensasCreateManyArgs} args - Arguments to create many Defensas.
     *     @example
     *     // Create many Defensas
     *     const defensas = await prisma.defensas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends defensasCreateManyArgs>(
      args?: SelectSubset<T, defensasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Defensas.
     * @param {defensasDeleteArgs} args - Arguments to delete one Defensas.
     * @example
     * // Delete one Defensas
     * const Defensas = await prisma.defensas.delete({
     *   where: {
     *     // ... filter to delete one Defensas
     *   }
     * })
     * 
    **/
    delete<T extends defensasDeleteArgs>(
      args: SelectSubset<T, defensasDeleteArgs>
    ): Prisma__defensasClient<defensasGetPayload<T>>

    /**
     * Update one Defensas.
     * @param {defensasUpdateArgs} args - Arguments to update one Defensas.
     * @example
     * // Update one Defensas
     * const defensas = await prisma.defensas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends defensasUpdateArgs>(
      args: SelectSubset<T, defensasUpdateArgs>
    ): Prisma__defensasClient<defensasGetPayload<T>>

    /**
     * Delete zero or more Defensas.
     * @param {defensasDeleteManyArgs} args - Arguments to filter Defensas to delete.
     * @example
     * // Delete a few Defensas
     * const { count } = await prisma.defensas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends defensasDeleteManyArgs>(
      args?: SelectSubset<T, defensasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defensasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Defensas
     * const defensas = await prisma.defensas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends defensasUpdateManyArgs>(
      args: SelectSubset<T, defensasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Defensas.
     * @param {defensasUpsertArgs} args - Arguments to update or create a Defensas.
     * @example
     * // Update or create a Defensas
     * const defensas = await prisma.defensas.upsert({
     *   create: {
     *     // ... data to create a Defensas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Defensas we want to update
     *   }
     * })
    **/
    upsert<T extends defensasUpsertArgs>(
      args: SelectSubset<T, defensasUpsertArgs>
    ): Prisma__defensasClient<defensasGetPayload<T>>

    /**
     * Count the number of Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {defensasCountArgs} args - Arguments to filter Defensas to count.
     * @example
     * // Count the number of Defensas
     * const count = await prisma.defensas.count({
     *   where: {
     *     // ... the filter for the Defensas we want to count
     *   }
     * })
    **/
    count<T extends defensasCountArgs>(
      args?: Subset<T, defensasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DefensasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DefensasAggregateArgs>(args: Subset<T, DefensasAggregateArgs>): Prisma.PrismaPromise<GetDefensasAggregateType<T>>

    /**
     * Group by Defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DefensasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DefensasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DefensasGroupByArgs['orderBy'] }
        : { orderBy?: DefensasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DefensasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDefensasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for defensas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__defensasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reino_defensas<T extends defensas$reino_defensasArgs= {}>(args?: Subset<T, defensas$reino_defensasArgs>): Prisma.PrismaPromise<Array<reino_defensasGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * defensas base type for findUnique actions
   */
  export type defensasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * Filter, which defensas to fetch.
     */
    where: defensasWhereUniqueInput
  }

  /**
   * defensas findUnique
   */
  export interface defensasFindUniqueArgs extends defensasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * defensas findUniqueOrThrow
   */
  export type defensasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * Filter, which defensas to fetch.
     */
    where: defensasWhereUniqueInput
  }


  /**
   * defensas base type for findFirst actions
   */
  export type defensasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * Filter, which defensas to fetch.
     */
    where?: defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defensas to fetch.
     */
    orderBy?: Enumerable<defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for defensas.
     */
    cursor?: defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of defensas.
     */
    distinct?: Enumerable<DefensasScalarFieldEnum>
  }

  /**
   * defensas findFirst
   */
  export interface defensasFindFirstArgs extends defensasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * defensas findFirstOrThrow
   */
  export type defensasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * Filter, which defensas to fetch.
     */
    where?: defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defensas to fetch.
     */
    orderBy?: Enumerable<defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for defensas.
     */
    cursor?: defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of defensas.
     */
    distinct?: Enumerable<DefensasScalarFieldEnum>
  }


  /**
   * defensas findMany
   */
  export type defensasFindManyArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * Filter, which defensas to fetch.
     */
    where?: defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of defensas to fetch.
     */
    orderBy?: Enumerable<defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing defensas.
     */
    cursor?: defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` defensas.
     */
    skip?: number
    distinct?: Enumerable<DefensasScalarFieldEnum>
  }


  /**
   * defensas create
   */
  export type defensasCreateArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * The data needed to create a defensas.
     */
    data: XOR<defensasCreateInput, defensasUncheckedCreateInput>
  }


  /**
   * defensas createMany
   */
  export type defensasCreateManyArgs = {
    /**
     * The data used to create many defensas.
     */
    data: Enumerable<defensasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * defensas update
   */
  export type defensasUpdateArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * The data needed to update a defensas.
     */
    data: XOR<defensasUpdateInput, defensasUncheckedUpdateInput>
    /**
     * Choose, which defensas to update.
     */
    where: defensasWhereUniqueInput
  }


  /**
   * defensas updateMany
   */
  export type defensasUpdateManyArgs = {
    /**
     * The data used to update defensas.
     */
    data: XOR<defensasUpdateManyMutationInput, defensasUncheckedUpdateManyInput>
    /**
     * Filter which defensas to update
     */
    where?: defensasWhereInput
  }


  /**
   * defensas upsert
   */
  export type defensasUpsertArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * The filter to search for the defensas to update in case it exists.
     */
    where: defensasWhereUniqueInput
    /**
     * In case the defensas found by the `where` argument doesn't exist, create a new defensas with this data.
     */
    create: XOR<defensasCreateInput, defensasUncheckedCreateInput>
    /**
     * In case the defensas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<defensasUpdateInput, defensasUncheckedUpdateInput>
  }


  /**
   * defensas delete
   */
  export type defensasDeleteArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
    /**
     * Filter which defensas to delete.
     */
    where: defensasWhereUniqueInput
  }


  /**
   * defensas deleteMany
   */
  export type defensasDeleteManyArgs = {
    /**
     * Filter which defensas to delete
     */
    where?: defensasWhereInput
  }


  /**
   * defensas.reino_defensas
   */
  export type defensas$reino_defensasArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    where?: reino_defensasWhereInput
    orderBy?: Enumerable<reino_defensasOrderByWithRelationInput>
    cursor?: reino_defensasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Reino_defensasScalarFieldEnum>
  }


  /**
   * defensas without action
   */
  export type defensasArgs = {
    /**
     * Select specific fields to fetch from the defensas
     */
    select?: defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: defensasInclude | null
  }



  /**
   * Model reino_defensas
   */


  export type AggregateReino_defensas = {
    _count: Reino_defensasCountAggregateOutputType | null
    _avg: Reino_defensasAvgAggregateOutputType | null
    _sum: Reino_defensasSumAggregateOutputType | null
    _min: Reino_defensasMinAggregateOutputType | null
    _max: Reino_defensasMaxAggregateOutputType | null
  }

  export type Reino_defensasAvgAggregateOutputType = {
    reinoId: number | null
    defensaId: number | null
  }

  export type Reino_defensasSumAggregateOutputType = {
    reinoId: number | null
    defensaId: number | null
  }

  export type Reino_defensasMinAggregateOutputType = {
    reinoId: number | null
    defensaId: number | null
  }

  export type Reino_defensasMaxAggregateOutputType = {
    reinoId: number | null
    defensaId: number | null
  }

  export type Reino_defensasCountAggregateOutputType = {
    reinoId: number
    defensaId: number
    _all: number
  }


  export type Reino_defensasAvgAggregateInputType = {
    reinoId?: true
    defensaId?: true
  }

  export type Reino_defensasSumAggregateInputType = {
    reinoId?: true
    defensaId?: true
  }

  export type Reino_defensasMinAggregateInputType = {
    reinoId?: true
    defensaId?: true
  }

  export type Reino_defensasMaxAggregateInputType = {
    reinoId?: true
    defensaId?: true
  }

  export type Reino_defensasCountAggregateInputType = {
    reinoId?: true
    defensaId?: true
    _all?: true
  }

  export type Reino_defensasAggregateArgs = {
    /**
     * Filter which reino_defensas to aggregate.
     */
    where?: reino_defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reino_defensas to fetch.
     */
    orderBy?: Enumerable<reino_defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reino_defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reino_defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reino_defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reino_defensas
    **/
    _count?: true | Reino_defensasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reino_defensasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reino_defensasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reino_defensasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reino_defensasMaxAggregateInputType
  }

  export type GetReino_defensasAggregateType<T extends Reino_defensasAggregateArgs> = {
        [P in keyof T & keyof AggregateReino_defensas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReino_defensas[P]>
      : GetScalarType<T[P], AggregateReino_defensas[P]>
  }




  export type Reino_defensasGroupByArgs = {
    where?: reino_defensasWhereInput
    orderBy?: Enumerable<reino_defensasOrderByWithAggregationInput>
    by: Reino_defensasScalarFieldEnum[]
    having?: reino_defensasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reino_defensasCountAggregateInputType | true
    _avg?: Reino_defensasAvgAggregateInputType
    _sum?: Reino_defensasSumAggregateInputType
    _min?: Reino_defensasMinAggregateInputType
    _max?: Reino_defensasMaxAggregateInputType
  }


  export type Reino_defensasGroupByOutputType = {
    reinoId: number
    defensaId: number
    _count: Reino_defensasCountAggregateOutputType | null
    _avg: Reino_defensasAvgAggregateOutputType | null
    _sum: Reino_defensasSumAggregateOutputType | null
    _min: Reino_defensasMinAggregateOutputType | null
    _max: Reino_defensasMaxAggregateOutputType | null
  }

  type GetReino_defensasGroupByPayload<T extends Reino_defensasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Reino_defensasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reino_defensasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reino_defensasGroupByOutputType[P]>
            : GetScalarType<T[P], Reino_defensasGroupByOutputType[P]>
        }
      >
    >


  export type reino_defensasSelect = {
    reinoId?: boolean
    defensaId?: boolean
    reinos?: boolean | reinosArgs
    defensas?: boolean | defensasArgs
  }


  export type reino_defensasInclude = {
    reinos?: boolean | reinosArgs
    defensas?: boolean | defensasArgs
  }

  export type reino_defensasGetPayload<S extends boolean | null | undefined | reino_defensasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reino_defensas :
    S extends undefined ? never :
    S extends { include: any } & (reino_defensasArgs | reino_defensasFindManyArgs)
    ? reino_defensas  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reinos' ? reinosGetPayload<S['include'][P]> :
        P extends 'defensas' ? defensasGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (reino_defensasArgs | reino_defensasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reinos' ? reinosGetPayload<S['select'][P]> :
        P extends 'defensas' ? defensasGetPayload<S['select'][P]> :  P extends keyof reino_defensas ? reino_defensas[P] : never
  } 
      : reino_defensas


  type reino_defensasCountArgs = 
    Omit<reino_defensasFindManyArgs, 'select' | 'include'> & {
      select?: Reino_defensasCountAggregateInputType | true
    }

  export interface reino_defensasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Reino_defensas that matches the filter.
     * @param {reino_defensasFindUniqueArgs} args - Arguments to find a Reino_defensas
     * @example
     * // Get one Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reino_defensasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reino_defensasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reino_defensas'> extends True ? Prisma__reino_defensasClient<reino_defensasGetPayload<T>> : Prisma__reino_defensasClient<reino_defensasGetPayload<T> | null, null>

    /**
     * Find one Reino_defensas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reino_defensasFindUniqueOrThrowArgs} args - Arguments to find a Reino_defensas
     * @example
     * // Get one Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reino_defensasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reino_defensasFindUniqueOrThrowArgs>
    ): Prisma__reino_defensasClient<reino_defensasGetPayload<T>>

    /**
     * Find the first Reino_defensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reino_defensasFindFirstArgs} args - Arguments to find a Reino_defensas
     * @example
     * // Get one Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reino_defensasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reino_defensasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reino_defensas'> extends True ? Prisma__reino_defensasClient<reino_defensasGetPayload<T>> : Prisma__reino_defensasClient<reino_defensasGetPayload<T> | null, null>

    /**
     * Find the first Reino_defensas that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reino_defensasFindFirstOrThrowArgs} args - Arguments to find a Reino_defensas
     * @example
     * // Get one Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reino_defensasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reino_defensasFindFirstOrThrowArgs>
    ): Prisma__reino_defensasClient<reino_defensasGetPayload<T>>

    /**
     * Find zero or more Reino_defensas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reino_defensasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.findMany()
     * 
     * // Get first 10 Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.findMany({ take: 10 })
     * 
     * // Only select the `reinoId`
     * const reino_defensasWithReinoIdOnly = await prisma.reino_defensas.findMany({ select: { reinoId: true } })
     * 
    **/
    findMany<T extends reino_defensasFindManyArgs>(
      args?: SelectSubset<T, reino_defensasFindManyArgs>
    ): Prisma.PrismaPromise<Array<reino_defensasGetPayload<T>>>

    /**
     * Create a Reino_defensas.
     * @param {reino_defensasCreateArgs} args - Arguments to create a Reino_defensas.
     * @example
     * // Create one Reino_defensas
     * const Reino_defensas = await prisma.reino_defensas.create({
     *   data: {
     *     // ... data to create a Reino_defensas
     *   }
     * })
     * 
    **/
    create<T extends reino_defensasCreateArgs>(
      args: SelectSubset<T, reino_defensasCreateArgs>
    ): Prisma__reino_defensasClient<reino_defensasGetPayload<T>>

    /**
     * Create many Reino_defensas.
     *     @param {reino_defensasCreateManyArgs} args - Arguments to create many Reino_defensas.
     *     @example
     *     // Create many Reino_defensas
     *     const reino_defensas = await prisma.reino_defensas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reino_defensasCreateManyArgs>(
      args?: SelectSubset<T, reino_defensasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reino_defensas.
     * @param {reino_defensasDeleteArgs} args - Arguments to delete one Reino_defensas.
     * @example
     * // Delete one Reino_defensas
     * const Reino_defensas = await prisma.reino_defensas.delete({
     *   where: {
     *     // ... filter to delete one Reino_defensas
     *   }
     * })
     * 
    **/
    delete<T extends reino_defensasDeleteArgs>(
      args: SelectSubset<T, reino_defensasDeleteArgs>
    ): Prisma__reino_defensasClient<reino_defensasGetPayload<T>>

    /**
     * Update one Reino_defensas.
     * @param {reino_defensasUpdateArgs} args - Arguments to update one Reino_defensas.
     * @example
     * // Update one Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reino_defensasUpdateArgs>(
      args: SelectSubset<T, reino_defensasUpdateArgs>
    ): Prisma__reino_defensasClient<reino_defensasGetPayload<T>>

    /**
     * Delete zero or more Reino_defensas.
     * @param {reino_defensasDeleteManyArgs} args - Arguments to filter Reino_defensas to delete.
     * @example
     * // Delete a few Reino_defensas
     * const { count } = await prisma.reino_defensas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reino_defensasDeleteManyArgs>(
      args?: SelectSubset<T, reino_defensasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reino_defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reino_defensasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reino_defensasUpdateManyArgs>(
      args: SelectSubset<T, reino_defensasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reino_defensas.
     * @param {reino_defensasUpsertArgs} args - Arguments to update or create a Reino_defensas.
     * @example
     * // Update or create a Reino_defensas
     * const reino_defensas = await prisma.reino_defensas.upsert({
     *   create: {
     *     // ... data to create a Reino_defensas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reino_defensas we want to update
     *   }
     * })
    **/
    upsert<T extends reino_defensasUpsertArgs>(
      args: SelectSubset<T, reino_defensasUpsertArgs>
    ): Prisma__reino_defensasClient<reino_defensasGetPayload<T>>

    /**
     * Count the number of Reino_defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reino_defensasCountArgs} args - Arguments to filter Reino_defensas to count.
     * @example
     * // Count the number of Reino_defensas
     * const count = await prisma.reino_defensas.count({
     *   where: {
     *     // ... the filter for the Reino_defensas we want to count
     *   }
     * })
    **/
    count<T extends reino_defensasCountArgs>(
      args?: Subset<T, reino_defensasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reino_defensasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reino_defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reino_defensasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reino_defensasAggregateArgs>(args: Subset<T, Reino_defensasAggregateArgs>): Prisma.PrismaPromise<GetReino_defensasAggregateType<T>>

    /**
     * Group by Reino_defensas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reino_defensasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Reino_defensasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Reino_defensasGroupByArgs['orderBy'] }
        : { orderBy?: Reino_defensasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Reino_defensasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReino_defensasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reino_defensas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reino_defensasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reinos<T extends reinosArgs= {}>(args?: Subset<T, reinosArgs>): Prisma__reinosClient<reinosGetPayload<T> | Null>;

    defensas<T extends defensasArgs= {}>(args?: Subset<T, defensasArgs>): Prisma__defensasClient<defensasGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reino_defensas base type for findUnique actions
   */
  export type reino_defensasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * Filter, which reino_defensas to fetch.
     */
    where: reino_defensasWhereUniqueInput
  }

  /**
   * reino_defensas findUnique
   */
  export interface reino_defensasFindUniqueArgs extends reino_defensasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reino_defensas findUniqueOrThrow
   */
  export type reino_defensasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * Filter, which reino_defensas to fetch.
     */
    where: reino_defensasWhereUniqueInput
  }


  /**
   * reino_defensas base type for findFirst actions
   */
  export type reino_defensasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * Filter, which reino_defensas to fetch.
     */
    where?: reino_defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reino_defensas to fetch.
     */
    orderBy?: Enumerable<reino_defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reino_defensas.
     */
    cursor?: reino_defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reino_defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reino_defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reino_defensas.
     */
    distinct?: Enumerable<Reino_defensasScalarFieldEnum>
  }

  /**
   * reino_defensas findFirst
   */
  export interface reino_defensasFindFirstArgs extends reino_defensasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reino_defensas findFirstOrThrow
   */
  export type reino_defensasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * Filter, which reino_defensas to fetch.
     */
    where?: reino_defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reino_defensas to fetch.
     */
    orderBy?: Enumerable<reino_defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reino_defensas.
     */
    cursor?: reino_defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reino_defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reino_defensas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reino_defensas.
     */
    distinct?: Enumerable<Reino_defensasScalarFieldEnum>
  }


  /**
   * reino_defensas findMany
   */
  export type reino_defensasFindManyArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * Filter, which reino_defensas to fetch.
     */
    where?: reino_defensasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reino_defensas to fetch.
     */
    orderBy?: Enumerable<reino_defensasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reino_defensas.
     */
    cursor?: reino_defensasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reino_defensas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reino_defensas.
     */
    skip?: number
    distinct?: Enumerable<Reino_defensasScalarFieldEnum>
  }


  /**
   * reino_defensas create
   */
  export type reino_defensasCreateArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * The data needed to create a reino_defensas.
     */
    data: XOR<reino_defensasCreateInput, reino_defensasUncheckedCreateInput>
  }


  /**
   * reino_defensas createMany
   */
  export type reino_defensasCreateManyArgs = {
    /**
     * The data used to create many reino_defensas.
     */
    data: Enumerable<reino_defensasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reino_defensas update
   */
  export type reino_defensasUpdateArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * The data needed to update a reino_defensas.
     */
    data: XOR<reino_defensasUpdateInput, reino_defensasUncheckedUpdateInput>
    /**
     * Choose, which reino_defensas to update.
     */
    where: reino_defensasWhereUniqueInput
  }


  /**
   * reino_defensas updateMany
   */
  export type reino_defensasUpdateManyArgs = {
    /**
     * The data used to update reino_defensas.
     */
    data: XOR<reino_defensasUpdateManyMutationInput, reino_defensasUncheckedUpdateManyInput>
    /**
     * Filter which reino_defensas to update
     */
    where?: reino_defensasWhereInput
  }


  /**
   * reino_defensas upsert
   */
  export type reino_defensasUpsertArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * The filter to search for the reino_defensas to update in case it exists.
     */
    where: reino_defensasWhereUniqueInput
    /**
     * In case the reino_defensas found by the `where` argument doesn't exist, create a new reino_defensas with this data.
     */
    create: XOR<reino_defensasCreateInput, reino_defensasUncheckedCreateInput>
    /**
     * In case the reino_defensas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reino_defensasUpdateInput, reino_defensasUncheckedUpdateInput>
  }


  /**
   * reino_defensas delete
   */
  export type reino_defensasDeleteArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
    /**
     * Filter which reino_defensas to delete.
     */
    where: reino_defensasWhereUniqueInput
  }


  /**
   * reino_defensas deleteMany
   */
  export type reino_defensasDeleteManyArgs = {
    /**
     * Filter which reino_defensas to delete
     */
    where?: reino_defensasWhereInput
  }


  /**
   * reino_defensas without action
   */
  export type reino_defensasArgs = {
    /**
     * Select specific fields to fetch from the reino_defensas
     */
    select?: reino_defensasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reino_defensasInclude | null
  }



  /**
   * Model diplomacias
   */


  export type AggregateDiplomacias = {
    _count: DiplomaciasCountAggregateOutputType | null
    _avg: DiplomaciasAvgAggregateOutputType | null
    _sum: DiplomaciasSumAggregateOutputType | null
    _min: DiplomaciasMinAggregateOutputType | null
    _max: DiplomaciasMaxAggregateOutputType | null
  }

  export type DiplomaciasAvgAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
  }

  export type DiplomaciasSumAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
  }

  export type DiplomaciasMinAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
    es_aliado: boolean | null
  }

  export type DiplomaciasMaxAggregateOutputType = {
    id_reino_1: number | null
    id_reino_2: number | null
    es_aliado: boolean | null
  }

  export type DiplomaciasCountAggregateOutputType = {
    id_reino_1: number
    id_reino_2: number
    es_aliado: number
    _all: number
  }


  export type DiplomaciasAvgAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
  }

  export type DiplomaciasSumAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
  }

  export type DiplomaciasMinAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
    es_aliado?: true
  }

  export type DiplomaciasMaxAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
    es_aliado?: true
  }

  export type DiplomaciasCountAggregateInputType = {
    id_reino_1?: true
    id_reino_2?: true
    es_aliado?: true
    _all?: true
  }

  export type DiplomaciasAggregateArgs = {
    /**
     * Filter which diplomacias to aggregate.
     */
    where?: diplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diplomacias to fetch.
     */
    orderBy?: Enumerable<diplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: diplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diplomacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diplomacias
    **/
    _count?: true | DiplomaciasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiplomaciasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiplomaciasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiplomaciasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiplomaciasMaxAggregateInputType
  }

  export type GetDiplomaciasAggregateType<T extends DiplomaciasAggregateArgs> = {
        [P in keyof T & keyof AggregateDiplomacias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiplomacias[P]>
      : GetScalarType<T[P], AggregateDiplomacias[P]>
  }




  export type DiplomaciasGroupByArgs = {
    where?: diplomaciasWhereInput
    orderBy?: Enumerable<diplomaciasOrderByWithAggregationInput>
    by: DiplomaciasScalarFieldEnum[]
    having?: diplomaciasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiplomaciasCountAggregateInputType | true
    _avg?: DiplomaciasAvgAggregateInputType
    _sum?: DiplomaciasSumAggregateInputType
    _min?: DiplomaciasMinAggregateInputType
    _max?: DiplomaciasMaxAggregateInputType
  }


  export type DiplomaciasGroupByOutputType = {
    id_reino_1: number
    id_reino_2: number
    es_aliado: boolean
    _count: DiplomaciasCountAggregateOutputType | null
    _avg: DiplomaciasAvgAggregateOutputType | null
    _sum: DiplomaciasSumAggregateOutputType | null
    _min: DiplomaciasMinAggregateOutputType | null
    _max: DiplomaciasMaxAggregateOutputType | null
  }

  type GetDiplomaciasGroupByPayload<T extends DiplomaciasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DiplomaciasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiplomaciasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiplomaciasGroupByOutputType[P]>
            : GetScalarType<T[P], DiplomaciasGroupByOutputType[P]>
        }
      >
    >


  export type diplomaciasSelect = {
    id_reino_1?: boolean
    id_reino_2?: boolean
    es_aliado?: boolean
    reino1?: boolean | reinosArgs
    reino2?: boolean | reinosArgs
  }


  export type diplomaciasInclude = {
    reino1?: boolean | reinosArgs
    reino2?: boolean | reinosArgs
  }

  export type diplomaciasGetPayload<S extends boolean | null | undefined | diplomaciasArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? diplomacias :
    S extends undefined ? never :
    S extends { include: any } & (diplomaciasArgs | diplomaciasFindManyArgs)
    ? diplomacias  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'reino1' ? reinosGetPayload<S['include'][P]> :
        P extends 'reino2' ? reinosGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (diplomaciasArgs | diplomaciasFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'reino1' ? reinosGetPayload<S['select'][P]> :
        P extends 'reino2' ? reinosGetPayload<S['select'][P]> :  P extends keyof diplomacias ? diplomacias[P] : never
  } 
      : diplomacias


  type diplomaciasCountArgs = 
    Omit<diplomaciasFindManyArgs, 'select' | 'include'> & {
      select?: DiplomaciasCountAggregateInputType | true
    }

  export interface diplomaciasDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Diplomacias that matches the filter.
     * @param {diplomaciasFindUniqueArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends diplomaciasFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, diplomaciasFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'diplomacias'> extends True ? Prisma__diplomaciasClient<diplomaciasGetPayload<T>> : Prisma__diplomaciasClient<diplomaciasGetPayload<T> | null, null>

    /**
     * Find one Diplomacias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {diplomaciasFindUniqueOrThrowArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends diplomaciasFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, diplomaciasFindUniqueOrThrowArgs>
    ): Prisma__diplomaciasClient<diplomaciasGetPayload<T>>

    /**
     * Find the first Diplomacias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diplomaciasFindFirstArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends diplomaciasFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, diplomaciasFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'diplomacias'> extends True ? Prisma__diplomaciasClient<diplomaciasGetPayload<T>> : Prisma__diplomaciasClient<diplomaciasGetPayload<T> | null, null>

    /**
     * Find the first Diplomacias that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diplomaciasFindFirstOrThrowArgs} args - Arguments to find a Diplomacias
     * @example
     * // Get one Diplomacias
     * const diplomacias = await prisma.diplomacias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends diplomaciasFindFirstOrThrowArgs>(
      args?: SelectSubset<T, diplomaciasFindFirstOrThrowArgs>
    ): Prisma__diplomaciasClient<diplomaciasGetPayload<T>>

    /**
     * Find zero or more Diplomacias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diplomaciasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diplomacias
     * const diplomacias = await prisma.diplomacias.findMany()
     * 
     * // Get first 10 Diplomacias
     * const diplomacias = await prisma.diplomacias.findMany({ take: 10 })
     * 
     * // Only select the `id_reino_1`
     * const diplomaciasWithId_reino_1Only = await prisma.diplomacias.findMany({ select: { id_reino_1: true } })
     * 
    **/
    findMany<T extends diplomaciasFindManyArgs>(
      args?: SelectSubset<T, diplomaciasFindManyArgs>
    ): Prisma.PrismaPromise<Array<diplomaciasGetPayload<T>>>

    /**
     * Create a Diplomacias.
     * @param {diplomaciasCreateArgs} args - Arguments to create a Diplomacias.
     * @example
     * // Create one Diplomacias
     * const Diplomacias = await prisma.diplomacias.create({
     *   data: {
     *     // ... data to create a Diplomacias
     *   }
     * })
     * 
    **/
    create<T extends diplomaciasCreateArgs>(
      args: SelectSubset<T, diplomaciasCreateArgs>
    ): Prisma__diplomaciasClient<diplomaciasGetPayload<T>>

    /**
     * Create many Diplomacias.
     *     @param {diplomaciasCreateManyArgs} args - Arguments to create many Diplomacias.
     *     @example
     *     // Create many Diplomacias
     *     const diplomacias = await prisma.diplomacias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends diplomaciasCreateManyArgs>(
      args?: SelectSubset<T, diplomaciasCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diplomacias.
     * @param {diplomaciasDeleteArgs} args - Arguments to delete one Diplomacias.
     * @example
     * // Delete one Diplomacias
     * const Diplomacias = await prisma.diplomacias.delete({
     *   where: {
     *     // ... filter to delete one Diplomacias
     *   }
     * })
     * 
    **/
    delete<T extends diplomaciasDeleteArgs>(
      args: SelectSubset<T, diplomaciasDeleteArgs>
    ): Prisma__diplomaciasClient<diplomaciasGetPayload<T>>

    /**
     * Update one Diplomacias.
     * @param {diplomaciasUpdateArgs} args - Arguments to update one Diplomacias.
     * @example
     * // Update one Diplomacias
     * const diplomacias = await prisma.diplomacias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends diplomaciasUpdateArgs>(
      args: SelectSubset<T, diplomaciasUpdateArgs>
    ): Prisma__diplomaciasClient<diplomaciasGetPayload<T>>

    /**
     * Delete zero or more Diplomacias.
     * @param {diplomaciasDeleteManyArgs} args - Arguments to filter Diplomacias to delete.
     * @example
     * // Delete a few Diplomacias
     * const { count } = await prisma.diplomacias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends diplomaciasDeleteManyArgs>(
      args?: SelectSubset<T, diplomaciasDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diplomaciasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diplomacias
     * const diplomacias = await prisma.diplomacias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends diplomaciasUpdateManyArgs>(
      args: SelectSubset<T, diplomaciasUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diplomacias.
     * @param {diplomaciasUpsertArgs} args - Arguments to update or create a Diplomacias.
     * @example
     * // Update or create a Diplomacias
     * const diplomacias = await prisma.diplomacias.upsert({
     *   create: {
     *     // ... data to create a Diplomacias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diplomacias we want to update
     *   }
     * })
    **/
    upsert<T extends diplomaciasUpsertArgs>(
      args: SelectSubset<T, diplomaciasUpsertArgs>
    ): Prisma__diplomaciasClient<diplomaciasGetPayload<T>>

    /**
     * Count the number of Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {diplomaciasCountArgs} args - Arguments to filter Diplomacias to count.
     * @example
     * // Count the number of Diplomacias
     * const count = await prisma.diplomacias.count({
     *   where: {
     *     // ... the filter for the Diplomacias we want to count
     *   }
     * })
    **/
    count<T extends diplomaciasCountArgs>(
      args?: Subset<T, diplomaciasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiplomaciasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiplomaciasAggregateArgs>(args: Subset<T, DiplomaciasAggregateArgs>): Prisma.PrismaPromise<GetDiplomaciasAggregateType<T>>

    /**
     * Group by Diplomacias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomaciasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiplomaciasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiplomaciasGroupByArgs['orderBy'] }
        : { orderBy?: DiplomaciasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiplomaciasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiplomaciasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for diplomacias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__diplomaciasClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    reino1<T extends reinosArgs= {}>(args?: Subset<T, reinosArgs>): Prisma__reinosClient<reinosGetPayload<T> | Null>;

    reino2<T extends reinosArgs= {}>(args?: Subset<T, reinosArgs>): Prisma__reinosClient<reinosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * diplomacias base type for findUnique actions
   */
  export type diplomaciasFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * Filter, which diplomacias to fetch.
     */
    where: diplomaciasWhereUniqueInput
  }

  /**
   * diplomacias findUnique
   */
  export interface diplomaciasFindUniqueArgs extends diplomaciasFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * diplomacias findUniqueOrThrow
   */
  export type diplomaciasFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * Filter, which diplomacias to fetch.
     */
    where: diplomaciasWhereUniqueInput
  }


  /**
   * diplomacias base type for findFirst actions
   */
  export type diplomaciasFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * Filter, which diplomacias to fetch.
     */
    where?: diplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diplomacias to fetch.
     */
    orderBy?: Enumerable<diplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diplomacias.
     */
    cursor?: diplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diplomacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diplomacias.
     */
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }

  /**
   * diplomacias findFirst
   */
  export interface diplomaciasFindFirstArgs extends diplomaciasFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * diplomacias findFirstOrThrow
   */
  export type diplomaciasFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * Filter, which diplomacias to fetch.
     */
    where?: diplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diplomacias to fetch.
     */
    orderBy?: Enumerable<diplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diplomacias.
     */
    cursor?: diplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diplomacias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diplomacias.
     */
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * diplomacias findMany
   */
  export type diplomaciasFindManyArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * Filter, which diplomacias to fetch.
     */
    where?: diplomaciasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diplomacias to fetch.
     */
    orderBy?: Enumerable<diplomaciasOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diplomacias.
     */
    cursor?: diplomaciasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diplomacias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diplomacias.
     */
    skip?: number
    distinct?: Enumerable<DiplomaciasScalarFieldEnum>
  }


  /**
   * diplomacias create
   */
  export type diplomaciasCreateArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * The data needed to create a diplomacias.
     */
    data: XOR<diplomaciasCreateInput, diplomaciasUncheckedCreateInput>
  }


  /**
   * diplomacias createMany
   */
  export type diplomaciasCreateManyArgs = {
    /**
     * The data used to create many diplomacias.
     */
    data: Enumerable<diplomaciasCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * diplomacias update
   */
  export type diplomaciasUpdateArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * The data needed to update a diplomacias.
     */
    data: XOR<diplomaciasUpdateInput, diplomaciasUncheckedUpdateInput>
    /**
     * Choose, which diplomacias to update.
     */
    where: diplomaciasWhereUniqueInput
  }


  /**
   * diplomacias updateMany
   */
  export type diplomaciasUpdateManyArgs = {
    /**
     * The data used to update diplomacias.
     */
    data: XOR<diplomaciasUpdateManyMutationInput, diplomaciasUncheckedUpdateManyInput>
    /**
     * Filter which diplomacias to update
     */
    where?: diplomaciasWhereInput
  }


  /**
   * diplomacias upsert
   */
  export type diplomaciasUpsertArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * The filter to search for the diplomacias to update in case it exists.
     */
    where: diplomaciasWhereUniqueInput
    /**
     * In case the diplomacias found by the `where` argument doesn't exist, create a new diplomacias with this data.
     */
    create: XOR<diplomaciasCreateInput, diplomaciasUncheckedCreateInput>
    /**
     * In case the diplomacias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<diplomaciasUpdateInput, diplomaciasUncheckedUpdateInput>
  }


  /**
   * diplomacias delete
   */
  export type diplomaciasDeleteArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
    /**
     * Filter which diplomacias to delete.
     */
    where: diplomaciasWhereUniqueInput
  }


  /**
   * diplomacias deleteMany
   */
  export type diplomaciasDeleteManyArgs = {
    /**
     * Filter which diplomacias to delete
     */
    where?: diplomaciasWhereInput
  }


  /**
   * diplomacias without action
   */
  export type diplomaciasArgs = {
    /**
     * Select specific fields to fetch from the diplomacias
     */
    select?: diplomaciasSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: diplomaciasInclude | null
  }



  /**
   * Enums
   */

  export const DefensasScalarFieldEnum: {
    id: 'id',
    defensa: 'defensa'
  };

  export type DefensasScalarFieldEnum = (typeof DefensasScalarFieldEnum)[keyof typeof DefensasScalarFieldEnum]


  export const DiplomaciasScalarFieldEnum: {
    id_reino_1: 'id_reino_1',
    id_reino_2: 'id_reino_2',
    es_aliado: 'es_aliado'
  };

  export type DiplomaciasScalarFieldEnum = (typeof DiplomaciasScalarFieldEnum)[keyof typeof DiplomaciasScalarFieldEnum]


  export const KartsScalarFieldEnum: {
    id: 'id',
    modelo: 'modelo',
    color: 'color',
    velocidad_maxima: 'velocidad_maxima',
    id_personaje: 'id_personaje'
  };

  export type KartsScalarFieldEnum = (typeof KartsScalarFieldEnum)[keyof typeof KartsScalarFieldEnum]


  export const Personaje_habita_reinoScalarFieldEnum: {
    id_personaje: 'id_personaje',
    id_reino: 'id_reino',
    fecha_registro: 'fecha_registro',
    es_gobernante: 'es_gobernante'
  };

  export type Personaje_habita_reinoScalarFieldEnum = (typeof Personaje_habita_reinoScalarFieldEnum)[keyof typeof Personaje_habita_reinoScalarFieldEnum]


  export const Personaje_tiene_trabajoScalarFieldEnum: {
    id_trabajo: 'id_trabajo',
    id_personaje: 'id_personaje',
    fecha_inicio: 'fecha_inicio',
    fecha_termino: 'fecha_termino'
  };

  export type Personaje_tiene_trabajoScalarFieldEnum = (typeof Personaje_tiene_trabajoScalarFieldEnum)[keyof typeof Personaje_tiene_trabajoScalarFieldEnum]


  export const PersonajesScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    fuerza: 'fuerza',
    fecha_nacimiento: 'fecha_nacimiento',
    objeto: 'objeto'
  };

  export type PersonajesScalarFieldEnum = (typeof PersonajesScalarFieldEnum)[keyof typeof PersonajesScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const Reino_defensasScalarFieldEnum: {
    reinoId: 'reinoId',
    defensaId: 'defensaId'
  };

  export type Reino_defensasScalarFieldEnum = (typeof Reino_defensasScalarFieldEnum)[keyof typeof Reino_defensasScalarFieldEnum]


  export const ReinosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    ubicacion: 'ubicacion',
    superficie: 'superficie'
  };

  export type ReinosScalarFieldEnum = (typeof ReinosScalarFieldEnum)[keyof typeof ReinosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TrabajosScalarFieldEnum: {
    id: 'id',
    descripcion: 'descripcion',
    sueldo: 'sueldo'
  };

  export type TrabajosScalarFieldEnum = (typeof TrabajosScalarFieldEnum)[keyof typeof TrabajosScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type personajesWhereInput = {
    AND?: Enumerable<personajesWhereInput>
    OR?: Enumerable<personajesWhereInput>
    NOT?: Enumerable<personajesWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    fuerza?: IntFilter | number
    fecha_nacimiento?: DateTimeFilter | Date | string
    objeto?: StringNullableFilter | string | null
    personaje_tiene_trabajo?: Personaje_tiene_trabajoListRelationFilter
    karts?: KartsListRelationFilter
    personaje_habita_reino?: Personaje_habita_reinoListRelationFilter
  }

  export type personajesOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
    personaje_tiene_trabajo?: personaje_tiene_trabajoOrderByRelationAggregateInput
    karts?: kartsOrderByRelationAggregateInput
    personaje_habita_reino?: personaje_habita_reinoOrderByRelationAggregateInput
  }

  export type personajesWhereUniqueInput = {
    id?: number
  }

  export type personajesOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
    _count?: personajesCountOrderByAggregateInput
    _avg?: personajesAvgOrderByAggregateInput
    _max?: personajesMaxOrderByAggregateInput
    _min?: personajesMinOrderByAggregateInput
    _sum?: personajesSumOrderByAggregateInput
  }

  export type personajesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<personajesScalarWhereWithAggregatesInput>
    OR?: Enumerable<personajesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<personajesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    fuerza?: IntWithAggregatesFilter | number
    fecha_nacimiento?: DateTimeWithAggregatesFilter | Date | string
    objeto?: StringNullableWithAggregatesFilter | string | null
  }

  export type kartsWhereInput = {
    AND?: Enumerable<kartsWhereInput>
    OR?: Enumerable<kartsWhereInput>
    NOT?: Enumerable<kartsWhereInput>
    id?: IntFilter | number
    modelo?: StringFilter | string
    color?: StringFilter | string
    velocidad_maxima?: IntNullableFilter | number | null
    id_personaje?: IntFilter | number
    personaje?: XOR<PersonajesRelationFilter, personajesWhereInput>
  }

  export type kartsOrderByWithRelationInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
    personaje?: personajesOrderByWithRelationInput
  }

  export type kartsWhereUniqueInput = {
    id?: number
  }

  export type kartsOrderByWithAggregationInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
    _count?: kartsCountOrderByAggregateInput
    _avg?: kartsAvgOrderByAggregateInput
    _max?: kartsMaxOrderByAggregateInput
    _min?: kartsMinOrderByAggregateInput
    _sum?: kartsSumOrderByAggregateInput
  }

  export type kartsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<kartsScalarWhereWithAggregatesInput>
    OR?: Enumerable<kartsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<kartsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    modelo?: StringWithAggregatesFilter | string
    color?: StringWithAggregatesFilter | string
    velocidad_maxima?: IntNullableWithAggregatesFilter | number | null
    id_personaje?: IntWithAggregatesFilter | number
  }

  export type personaje_tiene_trabajoWhereInput = {
    AND?: Enumerable<personaje_tiene_trabajoWhereInput>
    OR?: Enumerable<personaje_tiene_trabajoWhereInput>
    NOT?: Enumerable<personaje_tiene_trabajoWhereInput>
    id_trabajo?: IntFilter | number
    id_personaje?: IntFilter | number
    fecha_inicio?: DateTimeFilter | Date | string
    fecha_termino?: DateTimeNullableFilter | Date | string | null
    trabajo?: XOR<TrabajosRelationFilter, trabajosWhereInput>
    personaje?: XOR<PersonajesRelationFilter, personajesWhereInput>
  }

  export type personaje_tiene_trabajoOrderByWithRelationInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
    trabajo?: trabajosOrderByWithRelationInput
    personaje?: personajesOrderByWithRelationInput
  }

  export type personaje_tiene_trabajoWhereUniqueInput = {
    id_trabajo_id_personaje?: personaje_tiene_trabajoId_trabajoId_personajeCompoundUniqueInput
  }

  export type personaje_tiene_trabajoOrderByWithAggregationInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
    _count?: personaje_tiene_trabajoCountOrderByAggregateInput
    _avg?: personaje_tiene_trabajoAvgOrderByAggregateInput
    _max?: personaje_tiene_trabajoMaxOrderByAggregateInput
    _min?: personaje_tiene_trabajoMinOrderByAggregateInput
    _sum?: personaje_tiene_trabajoSumOrderByAggregateInput
  }

  export type personaje_tiene_trabajoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<personaje_tiene_trabajoScalarWhereWithAggregatesInput>
    OR?: Enumerable<personaje_tiene_trabajoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<personaje_tiene_trabajoScalarWhereWithAggregatesInput>
    id_trabajo?: IntWithAggregatesFilter | number
    id_personaje?: IntWithAggregatesFilter | number
    fecha_inicio?: DateTimeWithAggregatesFilter | Date | string
    fecha_termino?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type trabajosWhereInput = {
    AND?: Enumerable<trabajosWhereInput>
    OR?: Enumerable<trabajosWhereInput>
    NOT?: Enumerable<trabajosWhereInput>
    id?: IntFilter | number
    descripcion?: StringFilter | string
    sueldo?: IntFilter | number
    personaje_tiene_trabajo?: Personaje_tiene_trabajoListRelationFilter
  }

  export type trabajosOrderByWithRelationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
    personaje_tiene_trabajo?: personaje_tiene_trabajoOrderByRelationAggregateInput
  }

  export type trabajosWhereUniqueInput = {
    id?: number
  }

  export type trabajosOrderByWithAggregationInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
    _count?: trabajosCountOrderByAggregateInput
    _avg?: trabajosAvgOrderByAggregateInput
    _max?: trabajosMaxOrderByAggregateInput
    _min?: trabajosMinOrderByAggregateInput
    _sum?: trabajosSumOrderByAggregateInput
  }

  export type trabajosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<trabajosScalarWhereWithAggregatesInput>
    OR?: Enumerable<trabajosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<trabajosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    descripcion?: StringWithAggregatesFilter | string
    sueldo?: IntWithAggregatesFilter | number
  }

  export type personaje_habita_reinoWhereInput = {
    AND?: Enumerable<personaje_habita_reinoWhereInput>
    OR?: Enumerable<personaje_habita_reinoWhereInput>
    NOT?: Enumerable<personaje_habita_reinoWhereInput>
    id_personaje?: IntFilter | number
    id_reino?: IntFilter | number
    fecha_registro?: DateTimeFilter | Date | string
    es_gobernante?: BoolFilter | boolean
    personaje?: XOR<PersonajesRelationFilter, personajesWhereInput>
    reino?: XOR<ReinosRelationFilter, reinosWhereInput>
  }

  export type personaje_habita_reinoOrderByWithRelationInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
    personaje?: personajesOrderByWithRelationInput
    reino?: reinosOrderByWithRelationInput
  }

  export type personaje_habita_reinoWhereUniqueInput = {
    id_personaje_id_reino?: personaje_habita_reinoId_personajeId_reinoCompoundUniqueInput
  }

  export type personaje_habita_reinoOrderByWithAggregationInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
    _count?: personaje_habita_reinoCountOrderByAggregateInput
    _avg?: personaje_habita_reinoAvgOrderByAggregateInput
    _max?: personaje_habita_reinoMaxOrderByAggregateInput
    _min?: personaje_habita_reinoMinOrderByAggregateInput
    _sum?: personaje_habita_reinoSumOrderByAggregateInput
  }

  export type personaje_habita_reinoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<personaje_habita_reinoScalarWhereWithAggregatesInput>
    OR?: Enumerable<personaje_habita_reinoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<personaje_habita_reinoScalarWhereWithAggregatesInput>
    id_personaje?: IntWithAggregatesFilter | number
    id_reino?: IntWithAggregatesFilter | number
    fecha_registro?: DateTimeWithAggregatesFilter | Date | string
    es_gobernante?: BoolWithAggregatesFilter | boolean
  }

  export type reinosWhereInput = {
    AND?: Enumerable<reinosWhereInput>
    OR?: Enumerable<reinosWhereInput>
    NOT?: Enumerable<reinosWhereInput>
    id?: IntFilter | number
    nombre?: StringFilter | string
    ubicacion?: StringFilter | string
    superficie?: IntFilter | number
    personaje_habita_reino?: Personaje_habita_reinoListRelationFilter
    diplomaciasAsociadas1?: DiplomaciasListRelationFilter
    diplomaciasAsociadas2?: DiplomaciasListRelationFilter
    reino_defensas?: Reino_defensasListRelationFilter
  }

  export type reinosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
    personaje_habita_reino?: personaje_habita_reinoOrderByRelationAggregateInput
    diplomaciasAsociadas1?: diplomaciasOrderByRelationAggregateInput
    diplomaciasAsociadas2?: diplomaciasOrderByRelationAggregateInput
    reino_defensas?: reino_defensasOrderByRelationAggregateInput
  }

  export type reinosWhereUniqueInput = {
    id?: number
  }

  export type reinosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
    _count?: reinosCountOrderByAggregateInput
    _avg?: reinosAvgOrderByAggregateInput
    _max?: reinosMaxOrderByAggregateInput
    _min?: reinosMinOrderByAggregateInput
    _sum?: reinosSumOrderByAggregateInput
  }

  export type reinosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reinosScalarWhereWithAggregatesInput>
    OR?: Enumerable<reinosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reinosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nombre?: StringWithAggregatesFilter | string
    ubicacion?: StringWithAggregatesFilter | string
    superficie?: IntWithAggregatesFilter | number
  }

  export type defensasWhereInput = {
    AND?: Enumerable<defensasWhereInput>
    OR?: Enumerable<defensasWhereInput>
    NOT?: Enumerable<defensasWhereInput>
    id?: IntFilter | number
    defensa?: StringFilter | string
    reino_defensas?: Reino_defensasListRelationFilter
  }

  export type defensasOrderByWithRelationInput = {
    id?: SortOrder
    defensa?: SortOrder
    reino_defensas?: reino_defensasOrderByRelationAggregateInput
  }

  export type defensasWhereUniqueInput = {
    id?: number
  }

  export type defensasOrderByWithAggregationInput = {
    id?: SortOrder
    defensa?: SortOrder
    _count?: defensasCountOrderByAggregateInput
    _avg?: defensasAvgOrderByAggregateInput
    _max?: defensasMaxOrderByAggregateInput
    _min?: defensasMinOrderByAggregateInput
    _sum?: defensasSumOrderByAggregateInput
  }

  export type defensasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<defensasScalarWhereWithAggregatesInput>
    OR?: Enumerable<defensasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<defensasScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    defensa?: StringWithAggregatesFilter | string
  }

  export type reino_defensasWhereInput = {
    AND?: Enumerable<reino_defensasWhereInput>
    OR?: Enumerable<reino_defensasWhereInput>
    NOT?: Enumerable<reino_defensasWhereInput>
    reinoId?: IntFilter | number
    defensaId?: IntFilter | number
    reinos?: XOR<ReinosRelationFilter, reinosWhereInput>
    defensas?: XOR<DefensasRelationFilter, defensasWhereInput>
  }

  export type reino_defensasOrderByWithRelationInput = {
    reinoId?: SortOrder
    defensaId?: SortOrder
    reinos?: reinosOrderByWithRelationInput
    defensas?: defensasOrderByWithRelationInput
  }

  export type reino_defensasWhereUniqueInput = {
    reinoId_defensaId?: reino_defensasReinoIdDefensaIdCompoundUniqueInput
  }

  export type reino_defensasOrderByWithAggregationInput = {
    reinoId?: SortOrder
    defensaId?: SortOrder
    _count?: reino_defensasCountOrderByAggregateInput
    _avg?: reino_defensasAvgOrderByAggregateInput
    _max?: reino_defensasMaxOrderByAggregateInput
    _min?: reino_defensasMinOrderByAggregateInput
    _sum?: reino_defensasSumOrderByAggregateInput
  }

  export type reino_defensasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reino_defensasScalarWhereWithAggregatesInput>
    OR?: Enumerable<reino_defensasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reino_defensasScalarWhereWithAggregatesInput>
    reinoId?: IntWithAggregatesFilter | number
    defensaId?: IntWithAggregatesFilter | number
  }

  export type diplomaciasWhereInput = {
    AND?: Enumerable<diplomaciasWhereInput>
    OR?: Enumerable<diplomaciasWhereInput>
    NOT?: Enumerable<diplomaciasWhereInput>
    id_reino_1?: IntFilter | number
    id_reino_2?: IntFilter | number
    es_aliado?: BoolFilter | boolean
    reino1?: XOR<ReinosRelationFilter, reinosWhereInput>
    reino2?: XOR<ReinosRelationFilter, reinosWhereInput>
  }

  export type diplomaciasOrderByWithRelationInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
    reino1?: reinosOrderByWithRelationInput
    reino2?: reinosOrderByWithRelationInput
  }

  export type diplomaciasWhereUniqueInput = {
    id_reino_1_id_reino_2?: diplomaciasId_reino_1Id_reino_2CompoundUniqueInput
  }

  export type diplomaciasOrderByWithAggregationInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
    _count?: diplomaciasCountOrderByAggregateInput
    _avg?: diplomaciasAvgOrderByAggregateInput
    _max?: diplomaciasMaxOrderByAggregateInput
    _min?: diplomaciasMinOrderByAggregateInput
    _sum?: diplomaciasSumOrderByAggregateInput
  }

  export type diplomaciasScalarWhereWithAggregatesInput = {
    AND?: Enumerable<diplomaciasScalarWhereWithAggregatesInput>
    OR?: Enumerable<diplomaciasScalarWhereWithAggregatesInput>
    NOT?: Enumerable<diplomaciasScalarWhereWithAggregatesInput>
    id_reino_1?: IntWithAggregatesFilter | number
    id_reino_2?: IntWithAggregatesFilter | number
    es_aliado?: BoolWithAggregatesFilter | boolean
  }

  export type personajesCreateInput = {
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput
    karts?: kartsCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: personaje_habita_reinoCreateNestedManyWithoutPersonajeInput
  }

  export type personajesUncheckedCreateInput = {
    id?: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput
    karts?: kartsUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type personajesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput
    karts?: kartsUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput
  }

  export type personajesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput
    karts?: kartsUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type personajesCreateManyInput = {
    id?: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
  }

  export type personajesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type personajesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type kartsCreateInput = {
    modelo: string
    color: string
    velocidad_maxima?: number | null
    personaje: personajesCreateNestedOneWithoutKartsInput
  }

  export type kartsUncheckedCreateInput = {
    id?: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
    id_personaje: number
  }

  export type kartsUpdateInput = {
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
    personaje?: personajesUpdateOneRequiredWithoutKartsNestedInput
  }

  export type kartsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
    id_personaje?: IntFieldUpdateOperationsInput | number
  }

  export type kartsCreateManyInput = {
    id?: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
    id_personaje: number
  }

  export type kartsUpdateManyMutationInput = {
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type kartsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
    id_personaje?: IntFieldUpdateOperationsInput | number
  }

  export type personaje_tiene_trabajoCreateInput = {
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
    trabajo: trabajosCreateNestedOneWithoutPersonaje_tiene_trabajoInput
    personaje: personajesCreateNestedOneWithoutPersonaje_tiene_trabajoInput
  }

  export type personaje_tiene_trabajoUncheckedCreateInput = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type personaje_tiene_trabajoUpdateInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trabajo?: trabajosUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
    personaje?: personajesUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
  }

  export type personaje_tiene_trabajoUncheckedUpdateInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personaje_tiene_trabajoCreateManyInput = {
    id_trabajo: number
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type personaje_tiene_trabajoUpdateManyMutationInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personaje_tiene_trabajoUncheckedUpdateManyInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trabajosCreateInput = {
    descripcion: string
    sueldo: number
    personaje_tiene_trabajo?: personaje_tiene_trabajoCreateNestedManyWithoutTrabajoInput
  }

  export type trabajosUncheckedCreateInput = {
    id?: number
    descripcion: string
    sueldo: number
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedCreateNestedManyWithoutTrabajoInput
  }

  export type trabajosUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
    personaje_tiene_trabajo?: personaje_tiene_trabajoUpdateManyWithoutTrabajoNestedInput
  }

  export type trabajosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedUpdateManyWithoutTrabajoNestedInput
  }

  export type trabajosCreateManyInput = {
    id?: number
    descripcion: string
    sueldo: number
  }

  export type trabajosUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type trabajosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type personaje_habita_reinoCreateInput = {
    fecha_registro: Date | string
    es_gobernante: boolean
    personaje: personajesCreateNestedOneWithoutPersonaje_habita_reinoInput
    reino: reinosCreateNestedOneWithoutPersonaje_habita_reinoInput
  }

  export type personaje_habita_reinoUncheckedCreateInput = {
    id_personaje: number
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type personaje_habita_reinoUpdateInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
    personaje?: personajesUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
    reino?: reinosUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
  }

  export type personaje_habita_reinoUncheckedUpdateInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type personaje_habita_reinoCreateManyInput = {
    id_personaje: number
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type personaje_habita_reinoUpdateManyMutationInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type personaje_habita_reinoUncheckedUpdateManyInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reinosCreateInput = {
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas1?: diplomaciasCreateNestedManyWithoutReino1Input
    diplomaciasAsociadas2?: diplomaciasCreateNestedManyWithoutReino2Input
    reino_defensas?: reino_defensasCreateNestedManyWithoutReinosInput
  }

  export type reinosUncheckedCreateInput = {
    id?: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas1?: diplomaciasUncheckedCreateNestedManyWithoutReino1Input
    diplomaciasAsociadas2?: diplomaciasUncheckedCreateNestedManyWithoutReino2Input
    reino_defensas?: reino_defensasUncheckedCreateNestedManyWithoutReinosInput
  }

  export type reinosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas1?: diplomaciasUpdateManyWithoutReino1NestedInput
    diplomaciasAsociadas2?: diplomaciasUpdateManyWithoutReino2NestedInput
    reino_defensas?: reino_defensasUpdateManyWithoutReinosNestedInput
  }

  export type reinosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas1?: diplomaciasUncheckedUpdateManyWithoutReino1NestedInput
    diplomaciasAsociadas2?: diplomaciasUncheckedUpdateManyWithoutReino2NestedInput
    reino_defensas?: reino_defensasUncheckedUpdateManyWithoutReinosNestedInput
  }

  export type reinosCreateManyInput = {
    id?: number
    nombre: string
    ubicacion: string
    superficie: number
  }

  export type reinosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
  }

  export type reinosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
  }

  export type defensasCreateInput = {
    defensa: string
    reino_defensas?: reino_defensasCreateNestedManyWithoutDefensasInput
  }

  export type defensasUncheckedCreateInput = {
    id?: number
    defensa: string
    reino_defensas?: reino_defensasUncheckedCreateNestedManyWithoutDefensasInput
  }

  export type defensasUpdateInput = {
    defensa?: StringFieldUpdateOperationsInput | string
    reino_defensas?: reino_defensasUpdateManyWithoutDefensasNestedInput
  }

  export type defensasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
    reino_defensas?: reino_defensasUncheckedUpdateManyWithoutDefensasNestedInput
  }

  export type defensasCreateManyInput = {
    id?: number
    defensa: string
  }

  export type defensasUpdateManyMutationInput = {
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type defensasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type reino_defensasCreateInput = {
    reinos: reinosCreateNestedOneWithoutReino_defensasInput
    defensas: defensasCreateNestedOneWithoutReino_defensasInput
  }

  export type reino_defensasUncheckedCreateInput = {
    reinoId: number
    defensaId: number
  }

  export type reino_defensasUpdateInput = {
    reinos?: reinosUpdateOneRequiredWithoutReino_defensasNestedInput
    defensas?: defensasUpdateOneRequiredWithoutReino_defensasNestedInput
  }

  export type reino_defensasUncheckedUpdateInput = {
    reinoId?: IntFieldUpdateOperationsInput | number
    defensaId?: IntFieldUpdateOperationsInput | number
  }

  export type reino_defensasCreateManyInput = {
    reinoId: number
    defensaId: number
  }

  export type reino_defensasUpdateManyMutationInput = {

  }

  export type reino_defensasUncheckedUpdateManyInput = {
    reinoId?: IntFieldUpdateOperationsInput | number
    defensaId?: IntFieldUpdateOperationsInput | number
  }

  export type diplomaciasCreateInput = {
    es_aliado: boolean
    reino1: reinosCreateNestedOneWithoutDiplomaciasAsociadas1Input
    reino2: reinosCreateNestedOneWithoutDiplomaciasAsociadas2Input
  }

  export type diplomaciasUncheckedCreateInput = {
    id_reino_1: number
    id_reino_2: number
    es_aliado: boolean
  }

  export type diplomaciasUpdateInput = {
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
    reino1?: reinosUpdateOneRequiredWithoutDiplomaciasAsociadas1NestedInput
    reino2?: reinosUpdateOneRequiredWithoutDiplomaciasAsociadas2NestedInput
  }

  export type diplomaciasUncheckedUpdateInput = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type diplomaciasCreateManyInput = {
    id_reino_1: number
    id_reino_2: number
    es_aliado: boolean
  }

  export type diplomaciasUpdateManyMutationInput = {
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type diplomaciasUncheckedUpdateManyInput = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type Personaje_tiene_trabajoListRelationFilter = {
    every?: personaje_tiene_trabajoWhereInput
    some?: personaje_tiene_trabajoWhereInput
    none?: personaje_tiene_trabajoWhereInput
  }

  export type KartsListRelationFilter = {
    every?: kartsWhereInput
    some?: kartsWhereInput
    none?: kartsWhereInput
  }

  export type Personaje_habita_reinoListRelationFilter = {
    every?: personaje_habita_reinoWhereInput
    some?: personaje_habita_reinoWhereInput
    none?: personaje_habita_reinoWhereInput
  }

  export type personaje_tiene_trabajoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kartsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type personaje_habita_reinoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type personajesCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
  }

  export type personajesAvgOrderByAggregateInput = {
    id?: SortOrder
    fuerza?: SortOrder
  }

  export type personajesMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
  }

  export type personajesMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    fuerza?: SortOrder
    fecha_nacimiento?: SortOrder
    objeto?: SortOrder
  }

  export type personajesSumOrderByAggregateInput = {
    id?: SortOrder
    fuerza?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type PersonajesRelationFilter = {
    is?: personajesWhereInput
    isNot?: personajesWhereInput
  }

  export type kartsCountOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type kartsAvgOrderByAggregateInput = {
    id?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type kartsMaxOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type kartsMinOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    color?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type kartsSumOrderByAggregateInput = {
    id?: SortOrder
    velocidad_maxima?: SortOrder
    id_personaje?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type TrabajosRelationFilter = {
    is?: trabajosWhereInput
    isNot?: trabajosWhereInput
  }

  export type personaje_tiene_trabajoId_trabajoId_personajeCompoundUniqueInput = {
    id_trabajo: number
    id_personaje: number
  }

  export type personaje_tiene_trabajoCountOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
  }

  export type personaje_tiene_trabajoAvgOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
  }

  export type personaje_tiene_trabajoMaxOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
  }

  export type personaje_tiene_trabajoMinOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
    fecha_inicio?: SortOrder
    fecha_termino?: SortOrder
  }

  export type personaje_tiene_trabajoSumOrderByAggregateInput = {
    id_trabajo?: SortOrder
    id_personaje?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type trabajosCountOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
  }

  export type trabajosAvgOrderByAggregateInput = {
    id?: SortOrder
    sueldo?: SortOrder
  }

  export type trabajosMaxOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
  }

  export type trabajosMinOrderByAggregateInput = {
    id?: SortOrder
    descripcion?: SortOrder
    sueldo?: SortOrder
  }

  export type trabajosSumOrderByAggregateInput = {
    id?: SortOrder
    sueldo?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type ReinosRelationFilter = {
    is?: reinosWhereInput
    isNot?: reinosWhereInput
  }

  export type personaje_habita_reinoId_personajeId_reinoCompoundUniqueInput = {
    id_personaje: number
    id_reino: number
  }

  export type personaje_habita_reinoCountOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
  }

  export type personaje_habita_reinoAvgOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
  }

  export type personaje_habita_reinoMaxOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
  }

  export type personaje_habita_reinoMinOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
    fecha_registro?: SortOrder
    es_gobernante?: SortOrder
  }

  export type personaje_habita_reinoSumOrderByAggregateInput = {
    id_personaje?: SortOrder
    id_reino?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DiplomaciasListRelationFilter = {
    every?: diplomaciasWhereInput
    some?: diplomaciasWhereInput
    none?: diplomaciasWhereInput
  }

  export type Reino_defensasListRelationFilter = {
    every?: reino_defensasWhereInput
    some?: reino_defensasWhereInput
    none?: reino_defensasWhereInput
  }

  export type diplomaciasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reino_defensasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reinosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
  }

  export type reinosAvgOrderByAggregateInput = {
    id?: SortOrder
    superficie?: SortOrder
  }

  export type reinosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
  }

  export type reinosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ubicacion?: SortOrder
    superficie?: SortOrder
  }

  export type reinosSumOrderByAggregateInput = {
    id?: SortOrder
    superficie?: SortOrder
  }

  export type defensasCountOrderByAggregateInput = {
    id?: SortOrder
    defensa?: SortOrder
  }

  export type defensasAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type defensasMaxOrderByAggregateInput = {
    id?: SortOrder
    defensa?: SortOrder
  }

  export type defensasMinOrderByAggregateInput = {
    id?: SortOrder
    defensa?: SortOrder
  }

  export type defensasSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DefensasRelationFilter = {
    is?: defensasWhereInput
    isNot?: defensasWhereInput
  }

  export type reino_defensasReinoIdDefensaIdCompoundUniqueInput = {
    reinoId: number
    defensaId: number
  }

  export type reino_defensasCountOrderByAggregateInput = {
    reinoId?: SortOrder
    defensaId?: SortOrder
  }

  export type reino_defensasAvgOrderByAggregateInput = {
    reinoId?: SortOrder
    defensaId?: SortOrder
  }

  export type reino_defensasMaxOrderByAggregateInput = {
    reinoId?: SortOrder
    defensaId?: SortOrder
  }

  export type reino_defensasMinOrderByAggregateInput = {
    reinoId?: SortOrder
    defensaId?: SortOrder
  }

  export type reino_defensasSumOrderByAggregateInput = {
    reinoId?: SortOrder
    defensaId?: SortOrder
  }

  export type diplomaciasId_reino_1Id_reino_2CompoundUniqueInput = {
    id_reino_1: number
    id_reino_2: number
  }

  export type diplomaciasCountOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
  }

  export type diplomaciasAvgOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
  }

  export type diplomaciasMaxOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
  }

  export type diplomaciasMinOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
    es_aliado?: SortOrder
  }

  export type diplomaciasSumOrderByAggregateInput = {
    id_reino_1?: SortOrder
    id_reino_2?: SortOrder
  }

  export type personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    createMany?: personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
  }

  export type kartsCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<kartsCreateWithoutPersonajeInput>, Enumerable<kartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<kartsCreateOrConnectWithoutPersonajeInput>
    createMany?: kartsCreateManyPersonajeInputEnvelope
    connect?: Enumerable<kartsWhereUniqueInput>
  }

  export type personaje_habita_reinoCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    createMany?: personaje_habita_reinoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
  }

  export type personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    createMany?: personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
  }

  export type kartsUncheckedCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<kartsCreateWithoutPersonajeInput>, Enumerable<kartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<kartsCreateOrConnectWithoutPersonajeInput>
    createMany?: kartsCreateManyPersonajeInputEnvelope
    connect?: Enumerable<kartsWhereUniqueInput>
  }

  export type personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    createMany?: personaje_habita_reinoCreateManyPersonajeInputEnvelope
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<personaje_tiene_trabajoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    set?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<personaje_tiene_trabajoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<personaje_tiene_trabajoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<personaje_tiene_trabajoScalarWhereInput>
  }

  export type kartsUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<kartsCreateWithoutPersonajeInput>, Enumerable<kartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<kartsCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<kartsUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: kartsCreateManyPersonajeInputEnvelope
    set?: Enumerable<kartsWhereUniqueInput>
    disconnect?: Enumerable<kartsWhereUniqueInput>
    delete?: Enumerable<kartsWhereUniqueInput>
    connect?: Enumerable<kartsWhereUniqueInput>
    update?: Enumerable<kartsUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<kartsUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<kartsScalarWhereInput>
  }

  export type personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<personaje_habita_reinoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: personaje_habita_reinoCreateManyPersonajeInputEnvelope
    set?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<personaje_habita_reinoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<personaje_habita_reinoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<personaje_habita_reinoScalarWhereInput>
  }

  export type personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutPersonajeInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<personaje_tiene_trabajoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: personaje_tiene_trabajoCreateManyPersonajeInputEnvelope
    set?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<personaje_tiene_trabajoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<personaje_tiene_trabajoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<personaje_tiene_trabajoScalarWhereInput>
  }

  export type kartsUncheckedUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<kartsCreateWithoutPersonajeInput>, Enumerable<kartsUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<kartsCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<kartsUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: kartsCreateManyPersonajeInputEnvelope
    set?: Enumerable<kartsWhereUniqueInput>
    disconnect?: Enumerable<kartsWhereUniqueInput>
    delete?: Enumerable<kartsWhereUniqueInput>
    connect?: Enumerable<kartsWhereUniqueInput>
    update?: Enumerable<kartsUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<kartsUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<kartsScalarWhereInput>
  }

  export type personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutPersonajeInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutPersonajeInput>
    upsert?: Enumerable<personaje_habita_reinoUpsertWithWhereUniqueWithoutPersonajeInput>
    createMany?: personaje_habita_reinoCreateManyPersonajeInputEnvelope
    set?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<personaje_habita_reinoUpdateWithWhereUniqueWithoutPersonajeInput>
    updateMany?: Enumerable<personaje_habita_reinoUpdateManyWithWhereWithoutPersonajeInput>
    deleteMany?: Enumerable<personaje_habita_reinoScalarWhereInput>
  }

  export type personajesCreateNestedOneWithoutKartsInput = {
    create?: XOR<personajesCreateWithoutKartsInput, personajesUncheckedCreateWithoutKartsInput>
    connectOrCreate?: personajesCreateOrConnectWithoutKartsInput
    connect?: personajesWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type personajesUpdateOneRequiredWithoutKartsNestedInput = {
    create?: XOR<personajesCreateWithoutKartsInput, personajesUncheckedCreateWithoutKartsInput>
    connectOrCreate?: personajesCreateOrConnectWithoutKartsInput
    upsert?: personajesUpsertWithoutKartsInput
    connect?: personajesWhereUniqueInput
    update?: XOR<personajesUpdateWithoutKartsInput, personajesUncheckedUpdateWithoutKartsInput>
  }

  export type trabajosCreateNestedOneWithoutPersonaje_tiene_trabajoInput = {
    create?: XOR<trabajosCreateWithoutPersonaje_tiene_trabajoInput, trabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: trabajosCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    connect?: trabajosWhereUniqueInput
  }

  export type personajesCreateNestedOneWithoutPersonaje_tiene_trabajoInput = {
    create?: XOR<personajesCreateWithoutPersonaje_tiene_trabajoInput, personajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: personajesCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    connect?: personajesWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type trabajosUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput = {
    create?: XOR<trabajosCreateWithoutPersonaje_tiene_trabajoInput, trabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: trabajosCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    upsert?: trabajosUpsertWithoutPersonaje_tiene_trabajoInput
    connect?: trabajosWhereUniqueInput
    update?: XOR<trabajosUpdateWithoutPersonaje_tiene_trabajoInput, trabajosUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
  }

  export type personajesUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput = {
    create?: XOR<personajesCreateWithoutPersonaje_tiene_trabajoInput, personajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
    connectOrCreate?: personajesCreateOrConnectWithoutPersonaje_tiene_trabajoInput
    upsert?: personajesUpsertWithoutPersonaje_tiene_trabajoInput
    connect?: personajesWhereUniqueInput
    update?: XOR<personajesUpdateWithoutPersonaje_tiene_trabajoInput, personajesUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
  }

  export type personaje_tiene_trabajoCreateNestedManyWithoutTrabajoInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    createMany?: personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
  }

  export type personaje_tiene_trabajoUncheckedCreateNestedManyWithoutTrabajoInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    createMany?: personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
  }

  export type personaje_tiene_trabajoUpdateManyWithoutTrabajoNestedInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    upsert?: Enumerable<personaje_tiene_trabajoUpsertWithWhereUniqueWithoutTrabajoInput>
    createMany?: personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    set?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<personaje_tiene_trabajoUpdateWithWhereUniqueWithoutTrabajoInput>
    updateMany?: Enumerable<personaje_tiene_trabajoUpdateManyWithWhereWithoutTrabajoInput>
    deleteMany?: Enumerable<personaje_tiene_trabajoScalarWhereInput>
  }

  export type personaje_tiene_trabajoUncheckedUpdateManyWithoutTrabajoNestedInput = {
    create?: XOR<Enumerable<personaje_tiene_trabajoCreateWithoutTrabajoInput>, Enumerable<personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>>
    connectOrCreate?: Enumerable<personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput>
    upsert?: Enumerable<personaje_tiene_trabajoUpsertWithWhereUniqueWithoutTrabajoInput>
    createMany?: personaje_tiene_trabajoCreateManyTrabajoInputEnvelope
    set?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    disconnect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    delete?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    connect?: Enumerable<personaje_tiene_trabajoWhereUniqueInput>
    update?: Enumerable<personaje_tiene_trabajoUpdateWithWhereUniqueWithoutTrabajoInput>
    updateMany?: Enumerable<personaje_tiene_trabajoUpdateManyWithWhereWithoutTrabajoInput>
    deleteMany?: Enumerable<personaje_tiene_trabajoScalarWhereInput>
  }

  export type personajesCreateNestedOneWithoutPersonaje_habita_reinoInput = {
    create?: XOR<personajesCreateWithoutPersonaje_habita_reinoInput, personajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: personajesCreateOrConnectWithoutPersonaje_habita_reinoInput
    connect?: personajesWhereUniqueInput
  }

  export type reinosCreateNestedOneWithoutPersonaje_habita_reinoInput = {
    create?: XOR<reinosCreateWithoutPersonaje_habita_reinoInput, reinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: reinosCreateOrConnectWithoutPersonaje_habita_reinoInput
    connect?: reinosWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type personajesUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput = {
    create?: XOR<personajesCreateWithoutPersonaje_habita_reinoInput, personajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: personajesCreateOrConnectWithoutPersonaje_habita_reinoInput
    upsert?: personajesUpsertWithoutPersonaje_habita_reinoInput
    connect?: personajesWhereUniqueInput
    update?: XOR<personajesUpdateWithoutPersonaje_habita_reinoInput, personajesUncheckedUpdateWithoutPersonaje_habita_reinoInput>
  }

  export type reinosUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput = {
    create?: XOR<reinosCreateWithoutPersonaje_habita_reinoInput, reinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
    connectOrCreate?: reinosCreateOrConnectWithoutPersonaje_habita_reinoInput
    upsert?: reinosUpsertWithoutPersonaje_habita_reinoInput
    connect?: reinosWhereUniqueInput
    update?: XOR<reinosUpdateWithoutPersonaje_habita_reinoInput, reinosUncheckedUpdateWithoutPersonaje_habita_reinoInput>
  }

  export type personaje_habita_reinoCreateNestedManyWithoutReinoInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    createMany?: personaje_habita_reinoCreateManyReinoInputEnvelope
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
  }

  export type diplomaciasCreateNestedManyWithoutReino1Input = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino1Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino1Input>
    createMany?: diplomaciasCreateManyReino1InputEnvelope
    connect?: Enumerable<diplomaciasWhereUniqueInput>
  }

  export type diplomaciasCreateNestedManyWithoutReino2Input = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino2Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino2Input>
    createMany?: diplomaciasCreateManyReino2InputEnvelope
    connect?: Enumerable<diplomaciasWhereUniqueInput>
  }

  export type reino_defensasCreateNestedManyWithoutReinosInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutReinosInput>, Enumerable<reino_defensasUncheckedCreateWithoutReinosInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutReinosInput>
    createMany?: reino_defensasCreateManyReinosInputEnvelope
    connect?: Enumerable<reino_defensasWhereUniqueInput>
  }

  export type personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    createMany?: personaje_habita_reinoCreateManyReinoInputEnvelope
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
  }

  export type diplomaciasUncheckedCreateNestedManyWithoutReino1Input = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino1Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino1Input>
    createMany?: diplomaciasCreateManyReino1InputEnvelope
    connect?: Enumerable<diplomaciasWhereUniqueInput>
  }

  export type diplomaciasUncheckedCreateNestedManyWithoutReino2Input = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino2Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino2Input>
    createMany?: diplomaciasCreateManyReino2InputEnvelope
    connect?: Enumerable<diplomaciasWhereUniqueInput>
  }

  export type reino_defensasUncheckedCreateNestedManyWithoutReinosInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutReinosInput>, Enumerable<reino_defensasUncheckedCreateWithoutReinosInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutReinosInput>
    createMany?: reino_defensasCreateManyReinosInputEnvelope
    connect?: Enumerable<reino_defensasWhereUniqueInput>
  }

  export type personaje_habita_reinoUpdateManyWithoutReinoNestedInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    upsert?: Enumerable<personaje_habita_reinoUpsertWithWhereUniqueWithoutReinoInput>
    createMany?: personaje_habita_reinoCreateManyReinoInputEnvelope
    set?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<personaje_habita_reinoUpdateWithWhereUniqueWithoutReinoInput>
    updateMany?: Enumerable<personaje_habita_reinoUpdateManyWithWhereWithoutReinoInput>
    deleteMany?: Enumerable<personaje_habita_reinoScalarWhereInput>
  }

  export type diplomaciasUpdateManyWithoutReino1NestedInput = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino1Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino1Input>
    upsert?: Enumerable<diplomaciasUpsertWithWhereUniqueWithoutReino1Input>
    createMany?: diplomaciasCreateManyReino1InputEnvelope
    set?: Enumerable<diplomaciasWhereUniqueInput>
    disconnect?: Enumerable<diplomaciasWhereUniqueInput>
    delete?: Enumerable<diplomaciasWhereUniqueInput>
    connect?: Enumerable<diplomaciasWhereUniqueInput>
    update?: Enumerable<diplomaciasUpdateWithWhereUniqueWithoutReino1Input>
    updateMany?: Enumerable<diplomaciasUpdateManyWithWhereWithoutReino1Input>
    deleteMany?: Enumerable<diplomaciasScalarWhereInput>
  }

  export type diplomaciasUpdateManyWithoutReino2NestedInput = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino2Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino2Input>
    upsert?: Enumerable<diplomaciasUpsertWithWhereUniqueWithoutReino2Input>
    createMany?: diplomaciasCreateManyReino2InputEnvelope
    set?: Enumerable<diplomaciasWhereUniqueInput>
    disconnect?: Enumerable<diplomaciasWhereUniqueInput>
    delete?: Enumerable<diplomaciasWhereUniqueInput>
    connect?: Enumerable<diplomaciasWhereUniqueInput>
    update?: Enumerable<diplomaciasUpdateWithWhereUniqueWithoutReino2Input>
    updateMany?: Enumerable<diplomaciasUpdateManyWithWhereWithoutReino2Input>
    deleteMany?: Enumerable<diplomaciasScalarWhereInput>
  }

  export type reino_defensasUpdateManyWithoutReinosNestedInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutReinosInput>, Enumerable<reino_defensasUncheckedCreateWithoutReinosInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutReinosInput>
    upsert?: Enumerable<reino_defensasUpsertWithWhereUniqueWithoutReinosInput>
    createMany?: reino_defensasCreateManyReinosInputEnvelope
    set?: Enumerable<reino_defensasWhereUniqueInput>
    disconnect?: Enumerable<reino_defensasWhereUniqueInput>
    delete?: Enumerable<reino_defensasWhereUniqueInput>
    connect?: Enumerable<reino_defensasWhereUniqueInput>
    update?: Enumerable<reino_defensasUpdateWithWhereUniqueWithoutReinosInput>
    updateMany?: Enumerable<reino_defensasUpdateManyWithWhereWithoutReinosInput>
    deleteMany?: Enumerable<reino_defensasScalarWhereInput>
  }

  export type personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput = {
    create?: XOR<Enumerable<personaje_habita_reinoCreateWithoutReinoInput>, Enumerable<personaje_habita_reinoUncheckedCreateWithoutReinoInput>>
    connectOrCreate?: Enumerable<personaje_habita_reinoCreateOrConnectWithoutReinoInput>
    upsert?: Enumerable<personaje_habita_reinoUpsertWithWhereUniqueWithoutReinoInput>
    createMany?: personaje_habita_reinoCreateManyReinoInputEnvelope
    set?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    disconnect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    delete?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    connect?: Enumerable<personaje_habita_reinoWhereUniqueInput>
    update?: Enumerable<personaje_habita_reinoUpdateWithWhereUniqueWithoutReinoInput>
    updateMany?: Enumerable<personaje_habita_reinoUpdateManyWithWhereWithoutReinoInput>
    deleteMany?: Enumerable<personaje_habita_reinoScalarWhereInput>
  }

  export type diplomaciasUncheckedUpdateManyWithoutReino1NestedInput = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino1Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino1Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino1Input>
    upsert?: Enumerable<diplomaciasUpsertWithWhereUniqueWithoutReino1Input>
    createMany?: diplomaciasCreateManyReino1InputEnvelope
    set?: Enumerable<diplomaciasWhereUniqueInput>
    disconnect?: Enumerable<diplomaciasWhereUniqueInput>
    delete?: Enumerable<diplomaciasWhereUniqueInput>
    connect?: Enumerable<diplomaciasWhereUniqueInput>
    update?: Enumerable<diplomaciasUpdateWithWhereUniqueWithoutReino1Input>
    updateMany?: Enumerable<diplomaciasUpdateManyWithWhereWithoutReino1Input>
    deleteMany?: Enumerable<diplomaciasScalarWhereInput>
  }

  export type diplomaciasUncheckedUpdateManyWithoutReino2NestedInput = {
    create?: XOR<Enumerable<diplomaciasCreateWithoutReino2Input>, Enumerable<diplomaciasUncheckedCreateWithoutReino2Input>>
    connectOrCreate?: Enumerable<diplomaciasCreateOrConnectWithoutReino2Input>
    upsert?: Enumerable<diplomaciasUpsertWithWhereUniqueWithoutReino2Input>
    createMany?: diplomaciasCreateManyReino2InputEnvelope
    set?: Enumerable<diplomaciasWhereUniqueInput>
    disconnect?: Enumerable<diplomaciasWhereUniqueInput>
    delete?: Enumerable<diplomaciasWhereUniqueInput>
    connect?: Enumerable<diplomaciasWhereUniqueInput>
    update?: Enumerable<diplomaciasUpdateWithWhereUniqueWithoutReino2Input>
    updateMany?: Enumerable<diplomaciasUpdateManyWithWhereWithoutReino2Input>
    deleteMany?: Enumerable<diplomaciasScalarWhereInput>
  }

  export type reino_defensasUncheckedUpdateManyWithoutReinosNestedInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutReinosInput>, Enumerable<reino_defensasUncheckedCreateWithoutReinosInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutReinosInput>
    upsert?: Enumerable<reino_defensasUpsertWithWhereUniqueWithoutReinosInput>
    createMany?: reino_defensasCreateManyReinosInputEnvelope
    set?: Enumerable<reino_defensasWhereUniqueInput>
    disconnect?: Enumerable<reino_defensasWhereUniqueInput>
    delete?: Enumerable<reino_defensasWhereUniqueInput>
    connect?: Enumerable<reino_defensasWhereUniqueInput>
    update?: Enumerable<reino_defensasUpdateWithWhereUniqueWithoutReinosInput>
    updateMany?: Enumerable<reino_defensasUpdateManyWithWhereWithoutReinosInput>
    deleteMany?: Enumerable<reino_defensasScalarWhereInput>
  }

  export type reino_defensasCreateNestedManyWithoutDefensasInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutDefensasInput>, Enumerable<reino_defensasUncheckedCreateWithoutDefensasInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutDefensasInput>
    createMany?: reino_defensasCreateManyDefensasInputEnvelope
    connect?: Enumerable<reino_defensasWhereUniqueInput>
  }

  export type reino_defensasUncheckedCreateNestedManyWithoutDefensasInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutDefensasInput>, Enumerable<reino_defensasUncheckedCreateWithoutDefensasInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutDefensasInput>
    createMany?: reino_defensasCreateManyDefensasInputEnvelope
    connect?: Enumerable<reino_defensasWhereUniqueInput>
  }

  export type reino_defensasUpdateManyWithoutDefensasNestedInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutDefensasInput>, Enumerable<reino_defensasUncheckedCreateWithoutDefensasInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutDefensasInput>
    upsert?: Enumerable<reino_defensasUpsertWithWhereUniqueWithoutDefensasInput>
    createMany?: reino_defensasCreateManyDefensasInputEnvelope
    set?: Enumerable<reino_defensasWhereUniqueInput>
    disconnect?: Enumerable<reino_defensasWhereUniqueInput>
    delete?: Enumerable<reino_defensasWhereUniqueInput>
    connect?: Enumerable<reino_defensasWhereUniqueInput>
    update?: Enumerable<reino_defensasUpdateWithWhereUniqueWithoutDefensasInput>
    updateMany?: Enumerable<reino_defensasUpdateManyWithWhereWithoutDefensasInput>
    deleteMany?: Enumerable<reino_defensasScalarWhereInput>
  }

  export type reino_defensasUncheckedUpdateManyWithoutDefensasNestedInput = {
    create?: XOR<Enumerable<reino_defensasCreateWithoutDefensasInput>, Enumerable<reino_defensasUncheckedCreateWithoutDefensasInput>>
    connectOrCreate?: Enumerable<reino_defensasCreateOrConnectWithoutDefensasInput>
    upsert?: Enumerable<reino_defensasUpsertWithWhereUniqueWithoutDefensasInput>
    createMany?: reino_defensasCreateManyDefensasInputEnvelope
    set?: Enumerable<reino_defensasWhereUniqueInput>
    disconnect?: Enumerable<reino_defensasWhereUniqueInput>
    delete?: Enumerable<reino_defensasWhereUniqueInput>
    connect?: Enumerable<reino_defensasWhereUniqueInput>
    update?: Enumerable<reino_defensasUpdateWithWhereUniqueWithoutDefensasInput>
    updateMany?: Enumerable<reino_defensasUpdateManyWithWhereWithoutDefensasInput>
    deleteMany?: Enumerable<reino_defensasScalarWhereInput>
  }

  export type reinosCreateNestedOneWithoutReino_defensasInput = {
    create?: XOR<reinosCreateWithoutReino_defensasInput, reinosUncheckedCreateWithoutReino_defensasInput>
    connectOrCreate?: reinosCreateOrConnectWithoutReino_defensasInput
    connect?: reinosWhereUniqueInput
  }

  export type defensasCreateNestedOneWithoutReino_defensasInput = {
    create?: XOR<defensasCreateWithoutReino_defensasInput, defensasUncheckedCreateWithoutReino_defensasInput>
    connectOrCreate?: defensasCreateOrConnectWithoutReino_defensasInput
    connect?: defensasWhereUniqueInput
  }

  export type reinosUpdateOneRequiredWithoutReino_defensasNestedInput = {
    create?: XOR<reinosCreateWithoutReino_defensasInput, reinosUncheckedCreateWithoutReino_defensasInput>
    connectOrCreate?: reinosCreateOrConnectWithoutReino_defensasInput
    upsert?: reinosUpsertWithoutReino_defensasInput
    connect?: reinosWhereUniqueInput
    update?: XOR<reinosUpdateWithoutReino_defensasInput, reinosUncheckedUpdateWithoutReino_defensasInput>
  }

  export type defensasUpdateOneRequiredWithoutReino_defensasNestedInput = {
    create?: XOR<defensasCreateWithoutReino_defensasInput, defensasUncheckedCreateWithoutReino_defensasInput>
    connectOrCreate?: defensasCreateOrConnectWithoutReino_defensasInput
    upsert?: defensasUpsertWithoutReino_defensasInput
    connect?: defensasWhereUniqueInput
    update?: XOR<defensasUpdateWithoutReino_defensasInput, defensasUncheckedUpdateWithoutReino_defensasInput>
  }

  export type reinosCreateNestedOneWithoutDiplomaciasAsociadas1Input = {
    create?: XOR<reinosCreateWithoutDiplomaciasAsociadas1Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas1Input>
    connectOrCreate?: reinosCreateOrConnectWithoutDiplomaciasAsociadas1Input
    connect?: reinosWhereUniqueInput
  }

  export type reinosCreateNestedOneWithoutDiplomaciasAsociadas2Input = {
    create?: XOR<reinosCreateWithoutDiplomaciasAsociadas2Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas2Input>
    connectOrCreate?: reinosCreateOrConnectWithoutDiplomaciasAsociadas2Input
    connect?: reinosWhereUniqueInput
  }

  export type reinosUpdateOneRequiredWithoutDiplomaciasAsociadas1NestedInput = {
    create?: XOR<reinosCreateWithoutDiplomaciasAsociadas1Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas1Input>
    connectOrCreate?: reinosCreateOrConnectWithoutDiplomaciasAsociadas1Input
    upsert?: reinosUpsertWithoutDiplomaciasAsociadas1Input
    connect?: reinosWhereUniqueInput
    update?: XOR<reinosUpdateWithoutDiplomaciasAsociadas1Input, reinosUncheckedUpdateWithoutDiplomaciasAsociadas1Input>
  }

  export type reinosUpdateOneRequiredWithoutDiplomaciasAsociadas2NestedInput = {
    create?: XOR<reinosCreateWithoutDiplomaciasAsociadas2Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas2Input>
    connectOrCreate?: reinosCreateOrConnectWithoutDiplomaciasAsociadas2Input
    upsert?: reinosUpsertWithoutDiplomaciasAsociadas2Input
    connect?: reinosWhereUniqueInput
    update?: XOR<reinosUpdateWithoutDiplomaciasAsociadas2Input, reinosUncheckedUpdateWithoutDiplomaciasAsociadas2Input>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type personaje_tiene_trabajoCreateWithoutPersonajeInput = {
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
    trabajo: trabajosCreateNestedOneWithoutPersonaje_tiene_trabajoInput
  }

  export type personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput = {
    id_trabajo: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type personaje_tiene_trabajoCreateOrConnectWithoutPersonajeInput = {
    where: personaje_tiene_trabajoWhereUniqueInput
    create: XOR<personaje_tiene_trabajoCreateWithoutPersonajeInput, personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>
  }

  export type personaje_tiene_trabajoCreateManyPersonajeInputEnvelope = {
    data: Enumerable<personaje_tiene_trabajoCreateManyPersonajeInput>
    skipDuplicates?: boolean
  }

  export type kartsCreateWithoutPersonajeInput = {
    modelo: string
    color: string
    velocidad_maxima?: number | null
  }

  export type kartsUncheckedCreateWithoutPersonajeInput = {
    id?: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
  }

  export type kartsCreateOrConnectWithoutPersonajeInput = {
    where: kartsWhereUniqueInput
    create: XOR<kartsCreateWithoutPersonajeInput, kartsUncheckedCreateWithoutPersonajeInput>
  }

  export type kartsCreateManyPersonajeInputEnvelope = {
    data: Enumerable<kartsCreateManyPersonajeInput>
    skipDuplicates?: boolean
  }

  export type personaje_habita_reinoCreateWithoutPersonajeInput = {
    fecha_registro: Date | string
    es_gobernante: boolean
    reino: reinosCreateNestedOneWithoutPersonaje_habita_reinoInput
  }

  export type personaje_habita_reinoUncheckedCreateWithoutPersonajeInput = {
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type personaje_habita_reinoCreateOrConnectWithoutPersonajeInput = {
    where: personaje_habita_reinoWhereUniqueInput
    create: XOR<personaje_habita_reinoCreateWithoutPersonajeInput, personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>
  }

  export type personaje_habita_reinoCreateManyPersonajeInputEnvelope = {
    data: Enumerable<personaje_habita_reinoCreateManyPersonajeInput>
    skipDuplicates?: boolean
  }

  export type personaje_tiene_trabajoUpsertWithWhereUniqueWithoutPersonajeInput = {
    where: personaje_tiene_trabajoWhereUniqueInput
    update: XOR<personaje_tiene_trabajoUpdateWithoutPersonajeInput, personaje_tiene_trabajoUncheckedUpdateWithoutPersonajeInput>
    create: XOR<personaje_tiene_trabajoCreateWithoutPersonajeInput, personaje_tiene_trabajoUncheckedCreateWithoutPersonajeInput>
  }

  export type personaje_tiene_trabajoUpdateWithWhereUniqueWithoutPersonajeInput = {
    where: personaje_tiene_trabajoWhereUniqueInput
    data: XOR<personaje_tiene_trabajoUpdateWithoutPersonajeInput, personaje_tiene_trabajoUncheckedUpdateWithoutPersonajeInput>
  }

  export type personaje_tiene_trabajoUpdateManyWithWhereWithoutPersonajeInput = {
    where: personaje_tiene_trabajoScalarWhereInput
    data: XOR<personaje_tiene_trabajoUpdateManyMutationInput, personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonaje_tiene_trabajoInput>
  }

  export type personaje_tiene_trabajoScalarWhereInput = {
    AND?: Enumerable<personaje_tiene_trabajoScalarWhereInput>
    OR?: Enumerable<personaje_tiene_trabajoScalarWhereInput>
    NOT?: Enumerable<personaje_tiene_trabajoScalarWhereInput>
    id_trabajo?: IntFilter | number
    id_personaje?: IntFilter | number
    fecha_inicio?: DateTimeFilter | Date | string
    fecha_termino?: DateTimeNullableFilter | Date | string | null
  }

  export type kartsUpsertWithWhereUniqueWithoutPersonajeInput = {
    where: kartsWhereUniqueInput
    update: XOR<kartsUpdateWithoutPersonajeInput, kartsUncheckedUpdateWithoutPersonajeInput>
    create: XOR<kartsCreateWithoutPersonajeInput, kartsUncheckedCreateWithoutPersonajeInput>
  }

  export type kartsUpdateWithWhereUniqueWithoutPersonajeInput = {
    where: kartsWhereUniqueInput
    data: XOR<kartsUpdateWithoutPersonajeInput, kartsUncheckedUpdateWithoutPersonajeInput>
  }

  export type kartsUpdateManyWithWhereWithoutPersonajeInput = {
    where: kartsScalarWhereInput
    data: XOR<kartsUpdateManyMutationInput, kartsUncheckedUpdateManyWithoutKartsInput>
  }

  export type kartsScalarWhereInput = {
    AND?: Enumerable<kartsScalarWhereInput>
    OR?: Enumerable<kartsScalarWhereInput>
    NOT?: Enumerable<kartsScalarWhereInput>
    id?: IntFilter | number
    modelo?: StringFilter | string
    color?: StringFilter | string
    velocidad_maxima?: IntNullableFilter | number | null
    id_personaje?: IntFilter | number
  }

  export type personaje_habita_reinoUpsertWithWhereUniqueWithoutPersonajeInput = {
    where: personaje_habita_reinoWhereUniqueInput
    update: XOR<personaje_habita_reinoUpdateWithoutPersonajeInput, personaje_habita_reinoUncheckedUpdateWithoutPersonajeInput>
    create: XOR<personaje_habita_reinoCreateWithoutPersonajeInput, personaje_habita_reinoUncheckedCreateWithoutPersonajeInput>
  }

  export type personaje_habita_reinoUpdateWithWhereUniqueWithoutPersonajeInput = {
    where: personaje_habita_reinoWhereUniqueInput
    data: XOR<personaje_habita_reinoUpdateWithoutPersonajeInput, personaje_habita_reinoUncheckedUpdateWithoutPersonajeInput>
  }

  export type personaje_habita_reinoUpdateManyWithWhereWithoutPersonajeInput = {
    where: personaje_habita_reinoScalarWhereInput
    data: XOR<personaje_habita_reinoUpdateManyMutationInput, personaje_habita_reinoUncheckedUpdateManyWithoutPersonaje_habita_reinoInput>
  }

  export type personaje_habita_reinoScalarWhereInput = {
    AND?: Enumerable<personaje_habita_reinoScalarWhereInput>
    OR?: Enumerable<personaje_habita_reinoScalarWhereInput>
    NOT?: Enumerable<personaje_habita_reinoScalarWhereInput>
    id_personaje?: IntFilter | number
    id_reino?: IntFilter | number
    fecha_registro?: DateTimeFilter | Date | string
    es_gobernante?: BoolFilter | boolean
  }

  export type personajesCreateWithoutKartsInput = {
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: personaje_habita_reinoCreateNestedManyWithoutPersonajeInput
  }

  export type personajesUncheckedCreateWithoutKartsInput = {
    id?: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type personajesCreateOrConnectWithoutKartsInput = {
    where: personajesWhereUniqueInput
    create: XOR<personajesCreateWithoutKartsInput, personajesUncheckedCreateWithoutKartsInput>
  }

  export type personajesUpsertWithoutKartsInput = {
    update: XOR<personajesUpdateWithoutKartsInput, personajesUncheckedUpdateWithoutKartsInput>
    create: XOR<personajesCreateWithoutKartsInput, personajesUncheckedCreateWithoutKartsInput>
  }

  export type personajesUpdateWithoutKartsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput
  }

  export type personajesUncheckedUpdateWithoutKartsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type trabajosCreateWithoutPersonaje_tiene_trabajoInput = {
    descripcion: string
    sueldo: number
  }

  export type trabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput = {
    id?: number
    descripcion: string
    sueldo: number
  }

  export type trabajosCreateOrConnectWithoutPersonaje_tiene_trabajoInput = {
    where: trabajosWhereUniqueInput
    create: XOR<trabajosCreateWithoutPersonaje_tiene_trabajoInput, trabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type personajesCreateWithoutPersonaje_tiene_trabajoInput = {
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    karts?: kartsCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: personaje_habita_reinoCreateNestedManyWithoutPersonajeInput
  }

  export type personajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput = {
    id?: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    karts?: kartsUncheckedCreateNestedManyWithoutPersonajeInput
    personaje_habita_reino?: personaje_habita_reinoUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type personajesCreateOrConnectWithoutPersonaje_tiene_trabajoInput = {
    where: personajesWhereUniqueInput
    create: XOR<personajesCreateWithoutPersonaje_tiene_trabajoInput, personajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type trabajosUpsertWithoutPersonaje_tiene_trabajoInput = {
    update: XOR<trabajosUpdateWithoutPersonaje_tiene_trabajoInput, trabajosUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
    create: XOR<trabajosCreateWithoutPersonaje_tiene_trabajoInput, trabajosUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type trabajosUpdateWithoutPersonaje_tiene_trabajoInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type trabajosUncheckedUpdateWithoutPersonaje_tiene_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    sueldo?: IntFieldUpdateOperationsInput | number
  }

  export type personajesUpsertWithoutPersonaje_tiene_trabajoInput = {
    update: XOR<personajesUpdateWithoutPersonaje_tiene_trabajoInput, personajesUncheckedUpdateWithoutPersonaje_tiene_trabajoInput>
    create: XOR<personajesCreateWithoutPersonaje_tiene_trabajoInput, personajesUncheckedCreateWithoutPersonaje_tiene_trabajoInput>
  }

  export type personajesUpdateWithoutPersonaje_tiene_trabajoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    karts?: kartsUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: personaje_habita_reinoUpdateManyWithoutPersonajeNestedInput
  }

  export type personajesUncheckedUpdateWithoutPersonaje_tiene_trabajoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    karts?: kartsUncheckedUpdateManyWithoutPersonajeNestedInput
    personaje_habita_reino?: personaje_habita_reinoUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type personaje_tiene_trabajoCreateWithoutTrabajoInput = {
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
    personaje: personajesCreateNestedOneWithoutPersonaje_tiene_trabajoInput
  }

  export type personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput = {
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type personaje_tiene_trabajoCreateOrConnectWithoutTrabajoInput = {
    where: personaje_tiene_trabajoWhereUniqueInput
    create: XOR<personaje_tiene_trabajoCreateWithoutTrabajoInput, personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>
  }

  export type personaje_tiene_trabajoCreateManyTrabajoInputEnvelope = {
    data: Enumerable<personaje_tiene_trabajoCreateManyTrabajoInput>
    skipDuplicates?: boolean
  }

  export type personaje_tiene_trabajoUpsertWithWhereUniqueWithoutTrabajoInput = {
    where: personaje_tiene_trabajoWhereUniqueInput
    update: XOR<personaje_tiene_trabajoUpdateWithoutTrabajoInput, personaje_tiene_trabajoUncheckedUpdateWithoutTrabajoInput>
    create: XOR<personaje_tiene_trabajoCreateWithoutTrabajoInput, personaje_tiene_trabajoUncheckedCreateWithoutTrabajoInput>
  }

  export type personaje_tiene_trabajoUpdateWithWhereUniqueWithoutTrabajoInput = {
    where: personaje_tiene_trabajoWhereUniqueInput
    data: XOR<personaje_tiene_trabajoUpdateWithoutTrabajoInput, personaje_tiene_trabajoUncheckedUpdateWithoutTrabajoInput>
  }

  export type personaje_tiene_trabajoUpdateManyWithWhereWithoutTrabajoInput = {
    where: personaje_tiene_trabajoScalarWhereInput
    data: XOR<personaje_tiene_trabajoUpdateManyMutationInput, personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonaje_tiene_trabajoInput>
  }

  export type personajesCreateWithoutPersonaje_habita_reinoInput = {
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoCreateNestedManyWithoutPersonajeInput
    karts?: kartsCreateNestedManyWithoutPersonajeInput
  }

  export type personajesUncheckedCreateWithoutPersonaje_habita_reinoInput = {
    id?: number
    nombre: string
    fuerza: number
    fecha_nacimiento: Date | string
    objeto?: string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedCreateNestedManyWithoutPersonajeInput
    karts?: kartsUncheckedCreateNestedManyWithoutPersonajeInput
  }

  export type personajesCreateOrConnectWithoutPersonaje_habita_reinoInput = {
    where: personajesWhereUniqueInput
    create: XOR<personajesCreateWithoutPersonaje_habita_reinoInput, personajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type reinosCreateWithoutPersonaje_habita_reinoInput = {
    nombre: string
    ubicacion: string
    superficie: number
    diplomaciasAsociadas1?: diplomaciasCreateNestedManyWithoutReino1Input
    diplomaciasAsociadas2?: diplomaciasCreateNestedManyWithoutReino2Input
    reino_defensas?: reino_defensasCreateNestedManyWithoutReinosInput
  }

  export type reinosUncheckedCreateWithoutPersonaje_habita_reinoInput = {
    id?: number
    nombre: string
    ubicacion: string
    superficie: number
    diplomaciasAsociadas1?: diplomaciasUncheckedCreateNestedManyWithoutReino1Input
    diplomaciasAsociadas2?: diplomaciasUncheckedCreateNestedManyWithoutReino2Input
    reino_defensas?: reino_defensasUncheckedCreateNestedManyWithoutReinosInput
  }

  export type reinosCreateOrConnectWithoutPersonaje_habita_reinoInput = {
    where: reinosWhereUniqueInput
    create: XOR<reinosCreateWithoutPersonaje_habita_reinoInput, reinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type personajesUpsertWithoutPersonaje_habita_reinoInput = {
    update: XOR<personajesUpdateWithoutPersonaje_habita_reinoInput, personajesUncheckedUpdateWithoutPersonaje_habita_reinoInput>
    create: XOR<personajesCreateWithoutPersonaje_habita_reinoInput, personajesUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type personajesUpdateWithoutPersonaje_habita_reinoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUpdateManyWithoutPersonajeNestedInput
    karts?: kartsUpdateManyWithoutPersonajeNestedInput
  }

  export type personajesUncheckedUpdateWithoutPersonaje_habita_reinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    fuerza?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    objeto?: NullableStringFieldUpdateOperationsInput | string | null
    personaje_tiene_trabajo?: personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonajeNestedInput
    karts?: kartsUncheckedUpdateManyWithoutPersonajeNestedInput
  }

  export type reinosUpsertWithoutPersonaje_habita_reinoInput = {
    update: XOR<reinosUpdateWithoutPersonaje_habita_reinoInput, reinosUncheckedUpdateWithoutPersonaje_habita_reinoInput>
    create: XOR<reinosCreateWithoutPersonaje_habita_reinoInput, reinosUncheckedCreateWithoutPersonaje_habita_reinoInput>
  }

  export type reinosUpdateWithoutPersonaje_habita_reinoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    diplomaciasAsociadas1?: diplomaciasUpdateManyWithoutReino1NestedInput
    diplomaciasAsociadas2?: diplomaciasUpdateManyWithoutReino2NestedInput
    reino_defensas?: reino_defensasUpdateManyWithoutReinosNestedInput
  }

  export type reinosUncheckedUpdateWithoutPersonaje_habita_reinoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    diplomaciasAsociadas1?: diplomaciasUncheckedUpdateManyWithoutReino1NestedInput
    diplomaciasAsociadas2?: diplomaciasUncheckedUpdateManyWithoutReino2NestedInput
    reino_defensas?: reino_defensasUncheckedUpdateManyWithoutReinosNestedInput
  }

  export type personaje_habita_reinoCreateWithoutReinoInput = {
    fecha_registro: Date | string
    es_gobernante: boolean
    personaje: personajesCreateNestedOneWithoutPersonaje_habita_reinoInput
  }

  export type personaje_habita_reinoUncheckedCreateWithoutReinoInput = {
    id_personaje: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type personaje_habita_reinoCreateOrConnectWithoutReinoInput = {
    where: personaje_habita_reinoWhereUniqueInput
    create: XOR<personaje_habita_reinoCreateWithoutReinoInput, personaje_habita_reinoUncheckedCreateWithoutReinoInput>
  }

  export type personaje_habita_reinoCreateManyReinoInputEnvelope = {
    data: Enumerable<personaje_habita_reinoCreateManyReinoInput>
    skipDuplicates?: boolean
  }

  export type diplomaciasCreateWithoutReino1Input = {
    es_aliado: boolean
    reino2: reinosCreateNestedOneWithoutDiplomaciasAsociadas2Input
  }

  export type diplomaciasUncheckedCreateWithoutReino1Input = {
    id_reino_2: number
    es_aliado: boolean
  }

  export type diplomaciasCreateOrConnectWithoutReino1Input = {
    where: diplomaciasWhereUniqueInput
    create: XOR<diplomaciasCreateWithoutReino1Input, diplomaciasUncheckedCreateWithoutReino1Input>
  }

  export type diplomaciasCreateManyReino1InputEnvelope = {
    data: Enumerable<diplomaciasCreateManyReino1Input>
    skipDuplicates?: boolean
  }

  export type diplomaciasCreateWithoutReino2Input = {
    es_aliado: boolean
    reino1: reinosCreateNestedOneWithoutDiplomaciasAsociadas1Input
  }

  export type diplomaciasUncheckedCreateWithoutReino2Input = {
    id_reino_1: number
    es_aliado: boolean
  }

  export type diplomaciasCreateOrConnectWithoutReino2Input = {
    where: diplomaciasWhereUniqueInput
    create: XOR<diplomaciasCreateWithoutReino2Input, diplomaciasUncheckedCreateWithoutReino2Input>
  }

  export type diplomaciasCreateManyReino2InputEnvelope = {
    data: Enumerable<diplomaciasCreateManyReino2Input>
    skipDuplicates?: boolean
  }

  export type reino_defensasCreateWithoutReinosInput = {
    defensas: defensasCreateNestedOneWithoutReino_defensasInput
  }

  export type reino_defensasUncheckedCreateWithoutReinosInput = {
    defensaId: number
  }

  export type reino_defensasCreateOrConnectWithoutReinosInput = {
    where: reino_defensasWhereUniqueInput
    create: XOR<reino_defensasCreateWithoutReinosInput, reino_defensasUncheckedCreateWithoutReinosInput>
  }

  export type reino_defensasCreateManyReinosInputEnvelope = {
    data: Enumerable<reino_defensasCreateManyReinosInput>
    skipDuplicates?: boolean
  }

  export type personaje_habita_reinoUpsertWithWhereUniqueWithoutReinoInput = {
    where: personaje_habita_reinoWhereUniqueInput
    update: XOR<personaje_habita_reinoUpdateWithoutReinoInput, personaje_habita_reinoUncheckedUpdateWithoutReinoInput>
    create: XOR<personaje_habita_reinoCreateWithoutReinoInput, personaje_habita_reinoUncheckedCreateWithoutReinoInput>
  }

  export type personaje_habita_reinoUpdateWithWhereUniqueWithoutReinoInput = {
    where: personaje_habita_reinoWhereUniqueInput
    data: XOR<personaje_habita_reinoUpdateWithoutReinoInput, personaje_habita_reinoUncheckedUpdateWithoutReinoInput>
  }

  export type personaje_habita_reinoUpdateManyWithWhereWithoutReinoInput = {
    where: personaje_habita_reinoScalarWhereInput
    data: XOR<personaje_habita_reinoUpdateManyMutationInput, personaje_habita_reinoUncheckedUpdateManyWithoutPersonaje_habita_reinoInput>
  }

  export type diplomaciasUpsertWithWhereUniqueWithoutReino1Input = {
    where: diplomaciasWhereUniqueInput
    update: XOR<diplomaciasUpdateWithoutReino1Input, diplomaciasUncheckedUpdateWithoutReino1Input>
    create: XOR<diplomaciasCreateWithoutReino1Input, diplomaciasUncheckedCreateWithoutReino1Input>
  }

  export type diplomaciasUpdateWithWhereUniqueWithoutReino1Input = {
    where: diplomaciasWhereUniqueInput
    data: XOR<diplomaciasUpdateWithoutReino1Input, diplomaciasUncheckedUpdateWithoutReino1Input>
  }

  export type diplomaciasUpdateManyWithWhereWithoutReino1Input = {
    where: diplomaciasScalarWhereInput
    data: XOR<diplomaciasUpdateManyMutationInput, diplomaciasUncheckedUpdateManyWithoutDiplomaciasAsociadas1Input>
  }

  export type diplomaciasScalarWhereInput = {
    AND?: Enumerable<diplomaciasScalarWhereInput>
    OR?: Enumerable<diplomaciasScalarWhereInput>
    NOT?: Enumerable<diplomaciasScalarWhereInput>
    id_reino_1?: IntFilter | number
    id_reino_2?: IntFilter | number
    es_aliado?: BoolFilter | boolean
  }

  export type diplomaciasUpsertWithWhereUniqueWithoutReino2Input = {
    where: diplomaciasWhereUniqueInput
    update: XOR<diplomaciasUpdateWithoutReino2Input, diplomaciasUncheckedUpdateWithoutReino2Input>
    create: XOR<diplomaciasCreateWithoutReino2Input, diplomaciasUncheckedCreateWithoutReino2Input>
  }

  export type diplomaciasUpdateWithWhereUniqueWithoutReino2Input = {
    where: diplomaciasWhereUniqueInput
    data: XOR<diplomaciasUpdateWithoutReino2Input, diplomaciasUncheckedUpdateWithoutReino2Input>
  }

  export type diplomaciasUpdateManyWithWhereWithoutReino2Input = {
    where: diplomaciasScalarWhereInput
    data: XOR<diplomaciasUpdateManyMutationInput, diplomaciasUncheckedUpdateManyWithoutDiplomaciasAsociadas2Input>
  }

  export type reino_defensasUpsertWithWhereUniqueWithoutReinosInput = {
    where: reino_defensasWhereUniqueInput
    update: XOR<reino_defensasUpdateWithoutReinosInput, reino_defensasUncheckedUpdateWithoutReinosInput>
    create: XOR<reino_defensasCreateWithoutReinosInput, reino_defensasUncheckedCreateWithoutReinosInput>
  }

  export type reino_defensasUpdateWithWhereUniqueWithoutReinosInput = {
    where: reino_defensasWhereUniqueInput
    data: XOR<reino_defensasUpdateWithoutReinosInput, reino_defensasUncheckedUpdateWithoutReinosInput>
  }

  export type reino_defensasUpdateManyWithWhereWithoutReinosInput = {
    where: reino_defensasScalarWhereInput
    data: XOR<reino_defensasUpdateManyMutationInput, reino_defensasUncheckedUpdateManyWithoutReino_defensasInput>
  }

  export type reino_defensasScalarWhereInput = {
    AND?: Enumerable<reino_defensasScalarWhereInput>
    OR?: Enumerable<reino_defensasScalarWhereInput>
    NOT?: Enumerable<reino_defensasScalarWhereInput>
    reinoId?: IntFilter | number
    defensaId?: IntFilter | number
  }

  export type reino_defensasCreateWithoutDefensasInput = {
    reinos: reinosCreateNestedOneWithoutReino_defensasInput
  }

  export type reino_defensasUncheckedCreateWithoutDefensasInput = {
    reinoId: number
  }

  export type reino_defensasCreateOrConnectWithoutDefensasInput = {
    where: reino_defensasWhereUniqueInput
    create: XOR<reino_defensasCreateWithoutDefensasInput, reino_defensasUncheckedCreateWithoutDefensasInput>
  }

  export type reino_defensasCreateManyDefensasInputEnvelope = {
    data: Enumerable<reino_defensasCreateManyDefensasInput>
    skipDuplicates?: boolean
  }

  export type reino_defensasUpsertWithWhereUniqueWithoutDefensasInput = {
    where: reino_defensasWhereUniqueInput
    update: XOR<reino_defensasUpdateWithoutDefensasInput, reino_defensasUncheckedUpdateWithoutDefensasInput>
    create: XOR<reino_defensasCreateWithoutDefensasInput, reino_defensasUncheckedCreateWithoutDefensasInput>
  }

  export type reino_defensasUpdateWithWhereUniqueWithoutDefensasInput = {
    where: reino_defensasWhereUniqueInput
    data: XOR<reino_defensasUpdateWithoutDefensasInput, reino_defensasUncheckedUpdateWithoutDefensasInput>
  }

  export type reino_defensasUpdateManyWithWhereWithoutDefensasInput = {
    where: reino_defensasScalarWhereInput
    data: XOR<reino_defensasUpdateManyMutationInput, reino_defensasUncheckedUpdateManyWithoutReino_defensasInput>
  }

  export type reinosCreateWithoutReino_defensasInput = {
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas1?: diplomaciasCreateNestedManyWithoutReino1Input
    diplomaciasAsociadas2?: diplomaciasCreateNestedManyWithoutReino2Input
  }

  export type reinosUncheckedCreateWithoutReino_defensasInput = {
    id?: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas1?: diplomaciasUncheckedCreateNestedManyWithoutReino1Input
    diplomaciasAsociadas2?: diplomaciasUncheckedCreateNestedManyWithoutReino2Input
  }

  export type reinosCreateOrConnectWithoutReino_defensasInput = {
    where: reinosWhereUniqueInput
    create: XOR<reinosCreateWithoutReino_defensasInput, reinosUncheckedCreateWithoutReino_defensasInput>
  }

  export type defensasCreateWithoutReino_defensasInput = {
    defensa: string
  }

  export type defensasUncheckedCreateWithoutReino_defensasInput = {
    id?: number
    defensa: string
  }

  export type defensasCreateOrConnectWithoutReino_defensasInput = {
    where: defensasWhereUniqueInput
    create: XOR<defensasCreateWithoutReino_defensasInput, defensasUncheckedCreateWithoutReino_defensasInput>
  }

  export type reinosUpsertWithoutReino_defensasInput = {
    update: XOR<reinosUpdateWithoutReino_defensasInput, reinosUncheckedUpdateWithoutReino_defensasInput>
    create: XOR<reinosCreateWithoutReino_defensasInput, reinosUncheckedCreateWithoutReino_defensasInput>
  }

  export type reinosUpdateWithoutReino_defensasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas1?: diplomaciasUpdateManyWithoutReino1NestedInput
    diplomaciasAsociadas2?: diplomaciasUpdateManyWithoutReino2NestedInput
  }

  export type reinosUncheckedUpdateWithoutReino_defensasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas1?: diplomaciasUncheckedUpdateManyWithoutReino1NestedInput
    diplomaciasAsociadas2?: diplomaciasUncheckedUpdateManyWithoutReino2NestedInput
  }

  export type defensasUpsertWithoutReino_defensasInput = {
    update: XOR<defensasUpdateWithoutReino_defensasInput, defensasUncheckedUpdateWithoutReino_defensasInput>
    create: XOR<defensasCreateWithoutReino_defensasInput, defensasUncheckedCreateWithoutReino_defensasInput>
  }

  export type defensasUpdateWithoutReino_defensasInput = {
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type defensasUncheckedUpdateWithoutReino_defensasInput = {
    id?: IntFieldUpdateOperationsInput | number
    defensa?: StringFieldUpdateOperationsInput | string
  }

  export type reinosCreateWithoutDiplomaciasAsociadas1Input = {
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas2?: diplomaciasCreateNestedManyWithoutReino2Input
    reino_defensas?: reino_defensasCreateNestedManyWithoutReinosInput
  }

  export type reinosUncheckedCreateWithoutDiplomaciasAsociadas1Input = {
    id?: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas2?: diplomaciasUncheckedCreateNestedManyWithoutReino2Input
    reino_defensas?: reino_defensasUncheckedCreateNestedManyWithoutReinosInput
  }

  export type reinosCreateOrConnectWithoutDiplomaciasAsociadas1Input = {
    where: reinosWhereUniqueInput
    create: XOR<reinosCreateWithoutDiplomaciasAsociadas1Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas1Input>
  }

  export type reinosCreateWithoutDiplomaciasAsociadas2Input = {
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas1?: diplomaciasCreateNestedManyWithoutReino1Input
    reino_defensas?: reino_defensasCreateNestedManyWithoutReinosInput
  }

  export type reinosUncheckedCreateWithoutDiplomaciasAsociadas2Input = {
    id?: number
    nombre: string
    ubicacion: string
    superficie: number
    personaje_habita_reino?: personaje_habita_reinoUncheckedCreateNestedManyWithoutReinoInput
    diplomaciasAsociadas1?: diplomaciasUncheckedCreateNestedManyWithoutReino1Input
    reino_defensas?: reino_defensasUncheckedCreateNestedManyWithoutReinosInput
  }

  export type reinosCreateOrConnectWithoutDiplomaciasAsociadas2Input = {
    where: reinosWhereUniqueInput
    create: XOR<reinosCreateWithoutDiplomaciasAsociadas2Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas2Input>
  }

  export type reinosUpsertWithoutDiplomaciasAsociadas1Input = {
    update: XOR<reinosUpdateWithoutDiplomaciasAsociadas1Input, reinosUncheckedUpdateWithoutDiplomaciasAsociadas1Input>
    create: XOR<reinosCreateWithoutDiplomaciasAsociadas1Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas1Input>
  }

  export type reinosUpdateWithoutDiplomaciasAsociadas1Input = {
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas2?: diplomaciasUpdateManyWithoutReino2NestedInput
    reino_defensas?: reino_defensasUpdateManyWithoutReinosNestedInput
  }

  export type reinosUncheckedUpdateWithoutDiplomaciasAsociadas1Input = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas2?: diplomaciasUncheckedUpdateManyWithoutReino2NestedInput
    reino_defensas?: reino_defensasUncheckedUpdateManyWithoutReinosNestedInput
  }

  export type reinosUpsertWithoutDiplomaciasAsociadas2Input = {
    update: XOR<reinosUpdateWithoutDiplomaciasAsociadas2Input, reinosUncheckedUpdateWithoutDiplomaciasAsociadas2Input>
    create: XOR<reinosCreateWithoutDiplomaciasAsociadas2Input, reinosUncheckedCreateWithoutDiplomaciasAsociadas2Input>
  }

  export type reinosUpdateWithoutDiplomaciasAsociadas2Input = {
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas1?: diplomaciasUpdateManyWithoutReino1NestedInput
    reino_defensas?: reino_defensasUpdateManyWithoutReinosNestedInput
  }

  export type reinosUncheckedUpdateWithoutDiplomaciasAsociadas2Input = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ubicacion?: StringFieldUpdateOperationsInput | string
    superficie?: IntFieldUpdateOperationsInput | number
    personaje_habita_reino?: personaje_habita_reinoUncheckedUpdateManyWithoutReinoNestedInput
    diplomaciasAsociadas1?: diplomaciasUncheckedUpdateManyWithoutReino1NestedInput
    reino_defensas?: reino_defensasUncheckedUpdateManyWithoutReinosNestedInput
  }

  export type personaje_tiene_trabajoCreateManyPersonajeInput = {
    id_trabajo: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type kartsCreateManyPersonajeInput = {
    id?: number
    modelo: string
    color: string
    velocidad_maxima?: number | null
  }

  export type personaje_habita_reinoCreateManyPersonajeInput = {
    id_reino: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type personaje_tiene_trabajoUpdateWithoutPersonajeInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trabajo?: trabajosUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
  }

  export type personaje_tiene_trabajoUncheckedUpdateWithoutPersonajeInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personaje_tiene_trabajoUncheckedUpdateManyWithoutPersonaje_tiene_trabajoInput = {
    id_trabajo?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type kartsUpdateWithoutPersonajeInput = {
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type kartsUncheckedUpdateWithoutPersonajeInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type kartsUncheckedUpdateManyWithoutKartsInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    velocidad_maxima?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type personaje_habita_reinoUpdateWithoutPersonajeInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
    reino?: reinosUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
  }

  export type personaje_habita_reinoUncheckedUpdateWithoutPersonajeInput = {
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type personaje_habita_reinoUncheckedUpdateManyWithoutPersonaje_habita_reinoInput = {
    id_reino?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type personaje_tiene_trabajoCreateManyTrabajoInput = {
    id_personaje: number
    fecha_inicio: Date | string
    fecha_termino?: Date | string | null
  }

  export type personaje_tiene_trabajoUpdateWithoutTrabajoInput = {
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaje?: personajesUpdateOneRequiredWithoutPersonaje_tiene_trabajoNestedInput
  }

  export type personaje_tiene_trabajoUncheckedUpdateWithoutTrabajoInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_termino?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type personaje_habita_reinoCreateManyReinoInput = {
    id_personaje: number
    fecha_registro: Date | string
    es_gobernante: boolean
  }

  export type diplomaciasCreateManyReino1Input = {
    id_reino_2: number
    es_aliado: boolean
  }

  export type diplomaciasCreateManyReino2Input = {
    id_reino_1: number
    es_aliado: boolean
  }

  export type reino_defensasCreateManyReinosInput = {
    defensaId: number
  }

  export type personaje_habita_reinoUpdateWithoutReinoInput = {
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
    personaje?: personajesUpdateOneRequiredWithoutPersonaje_habita_reinoNestedInput
  }

  export type personaje_habita_reinoUncheckedUpdateWithoutReinoInput = {
    id_personaje?: IntFieldUpdateOperationsInput | number
    fecha_registro?: DateTimeFieldUpdateOperationsInput | Date | string
    es_gobernante?: BoolFieldUpdateOperationsInput | boolean
  }

  export type diplomaciasUpdateWithoutReino1Input = {
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
    reino2?: reinosUpdateOneRequiredWithoutDiplomaciasAsociadas2NestedInput
  }

  export type diplomaciasUncheckedUpdateWithoutReino1Input = {
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type diplomaciasUncheckedUpdateManyWithoutDiplomaciasAsociadas1Input = {
    id_reino_2?: IntFieldUpdateOperationsInput | number
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type diplomaciasUpdateWithoutReino2Input = {
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
    reino1?: reinosUpdateOneRequiredWithoutDiplomaciasAsociadas1NestedInput
  }

  export type diplomaciasUncheckedUpdateWithoutReino2Input = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type diplomaciasUncheckedUpdateManyWithoutDiplomaciasAsociadas2Input = {
    id_reino_1?: IntFieldUpdateOperationsInput | number
    es_aliado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reino_defensasUpdateWithoutReinosInput = {
    defensas?: defensasUpdateOneRequiredWithoutReino_defensasNestedInput
  }

  export type reino_defensasUncheckedUpdateWithoutReinosInput = {
    defensaId?: IntFieldUpdateOperationsInput | number
  }

  export type reino_defensasUncheckedUpdateManyWithoutReino_defensasInput = {
    defensaId?: IntFieldUpdateOperationsInput | number
  }

  export type reino_defensasCreateManyDefensasInput = {
    reinoId: number
  }

  export type reino_defensasUpdateWithoutDefensasInput = {
    reinos?: reinosUpdateOneRequiredWithoutReino_defensasNestedInput
  }

  export type reino_defensasUncheckedUpdateWithoutDefensasInput = {
    reinoId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}